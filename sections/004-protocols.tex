\section{Protocols and Composition}

\begin{definition}[Protocols]
An \emph{protocol} $\mathcal{P}$ consists of:
\begin{itemize}
\item Systems $P_1, \ldots, P_n$, called \emph{players}
\item A package $F$, called the \emph{ideal functionality}
\end{itemize}

Furthermore, we also impose requirements on the channels and functions
these elements use.

First, we require that the player systems are jointly closed,
with no extra channels that aren't connected to other players:
$$
\bigcup_{i \in [n]} \text{OutChan}(P_i) = \bigcup_{i \in [n]} \text{InChan}(P_i)
$$

Second, we require that the functions the systems depend on are disjoint:
$$
\forall i, j \in [n].\quad \text{In}(P_i) \cap \text{In}(P_j) = \emptyset
$$

Third, we require that the functions the systems export on are disjoint:
$$
\forall i, j \in [n].\quad \text{Out}(P_i) \cap \text{Out}(P_j) = \emptyset
$$

We can also define a few convenient notations related to the interface of a base
protocol.

Let $\text{Out}_i(\mathcal{P}) := \text{Out}(P_i)$, and let $\text{In}_i(\mathcal{P}) := \text{In}(P_i) / \text{Out}(F)$.
We then define $\text{Out}(\mathcal{P}) := \bigcup_{i \in [n]} \text{Out}_i(\mathcal{P})$
and $\text{In}(\mathcal{P}) := \bigcup_{i \in [n]} \text{In}_i(\mathcal{P})$.

Finally, we define
$$
\begin{aligned}
&\text{IdealIn}(\mathcal{P}) := \text{In}(F)\cr
&\text{Leakage}(\mathcal{P}) := \text{Out}(F) / \left(\bigcup_{i \in [n]} \tx{In}(P_i)\right)
\end{aligned}
$$

$\square$
\end{definition}

\begin{definition}[Closed Protocol]
  We say that a protocol $\mathcal{P}$ is \emph{closed} if
  $\tx{In}(\mathcal{P}) = \emptyset$ and $\tx{IdealIn}(\mathcal{P}) = \emptyset$.

  $\square$
\end{definition}

\begin{definition}[Literal Equality]
Given two protocols $\mathcal{P}$ and $\mathcal{Q}$, we say that
they are \emph{literally equal}, written as $\mathcal{P} \equiv \mathcal{Q}$
when:
\begin{itemize}
\item $\mathcal{P}.n = \mathcal{Q}.n$
\item There exists a permuation $\pi : [n] \leftrightarrow [n]$ such that
$
{\forall i \in [n].\enspace \mathcal{P}.P_i = \mathcal{Q}.P_{\pi(i)}}
$
\item $\mathcal{P}.F = \mathcal{P}.G$
\end{itemize}

$\square$
\end{definition}

\begin{definition}[Vertical Composition]
Given an protocol $\mathcal{P}$ and a package $G$, satisfying
$\text{IdealIn}(\mathcal{P}) \subseteq \text{Out}(G)$,
we can define the protocol $\mathcal{P} \circ G$.

$\mathcal{P} \circ G$ has the same players as $\mathcal{P}$,
but its ideal functionality $F$ becomes $F \circ G$.

$\square$
\end{definition}

\begin{claim}[Vertical Composition is Associative]
For any protocol $\mathcal{P}$, and packages $G, H$, such that their composition
is well defined, we have
$$
\mathcal{P} \circ (G \circ H) = (\mathcal{P} \circ G) \circ H
$$

\txbf{Proof:} This follows from the definition of vertical composition
and the associativity of $\circ$ for packages.
$\blacksquare$
\end{claim}

\begin{definition}[Horizontal Composition]
Given two protocols $\mathcal{P}, \mathcal{Q}$,
we can define the protocol $\mathcal{P} \lhd \mathcal{Q}$,
provided a few requirements hold.

First, we need: $\text{In}(\mathcal{P}) \subseteq \text{Out}(\mathcal{Q})$.
We also require that the functions exposed by a player in $\mathcal{Q}$
are used by \emph{exactly} one player in $\mathcal{P}$.
We express this as:
\[
  \forall i \in [\mathcal{Q}.n].\ \exists! j \in [\mathcal{P}.n].\quad \text{In}_j \cap \text{Out}_i \neq \emptyset
\]

Second, we require that the players share no channels between the two
protocols.
In other words $\text{Chan}(\mathcal{P}.P_i) \cap \text{Chan}(\mathcal{Q}.P_j) = \emptyset$, for all $P_i, P_j$.

Third, we require that the leakages of one game aren't use in the other:
$$
\begin{aligned}
&\tx{Leakage}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset\cr
&\tx{Leakage}(\mathcal{Q}) \cap \tx{In}(\mathcal{P}) = \emptyset
\end{aligned}
$$

Finally, we require that the ideal functionalities do not overlap, 
  in the sense that $\text{Out}(\mathcal{P}.F) \cap \text{Out}(\mathcal{Q}.F) = \emptyset$

Our first condition has an interesting consequence: every player $\mathcal{Q}.P_j$
has its functions used by exactly one player $\mathcal{P}.P_i$.
In that case, we say that $\mathcal{P}.P_i$ \emph{uses} $\mathcal{Q}.P_j$.

With this in hand, we can define $\mathcal{P} \lhd \mathcal{Q}$.

The players will consist of:
$$
  \mathcal{P}.P_i \circ \left( \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } \mathcal{Q}.P_j \right)
$$
And, because of our assumption, each player in $\mathcal{Q}$ appears
somewhere in this equation.

The ideal functionality is $\mathcal{P}.F \otimes \mathcal{Q}.F$.

We can also easily show that this definition is well defined, satisfying
the required properties of an protocol.
Because of the definition of the players, we see that:
$$
  \bigcup_{i \in [(\mathcal{P} \lhd \mathcal{Q}).n]} \tx{OutChan}((\mathcal{P} \lhd \mathcal{Q}).{P_i})
  = \left(\bigcup_{i \in [\mathcal{P}.n]} \tx{OutChan}(\mathcal{P}.P_i)\right) \cup
  \left(\bigcup_{i \in [\mathcal{Q}.n]} \tx{OutChan}(\mathcal{Q}.P_i)\right)
$$
  since $\text{OutChan}(A \circ B) = \text{OutChan}(A \otimes B) = \text{OutChan}(A, B)$.
A similar reasoning applies to $\text{InChan}$, allowing us to conclude that:
$$
  \bigcup_{i \in [(\mathcal{P} \lhd \mathcal{Q}).n]} \tx{OutChan}((\mathcal{P} \lhd \mathcal{Q}).{P_i}) =
  \bigcup_{i \in [(\mathcal{P} \lhd \mathcal{Q}).n]} \tx{InChan}((\mathcal{P} \lhd \mathcal{Q}).{P_i})
$$
as required.

By definition, the dependencies $\text{In}$ of each player in $\mathcal{P} \lhd \mathcal{Q}$
are the union of several players in $\mathcal{Q}$, so disjointness property
continues to hold.

Finally, since each player is of the form $\mathcal{P}.P_i \circ \ldots$,
the condition on $\text{Out}_i$ is also satisfied in $\mathcal{P} \lhd \mathcal{Q}$,
since $\mathcal{P}$ does.

$\square$

\end{definition}

\begin{lemma}
Horizontal composition is associative, i.e.
${\mathcal{P} \lhd (\mathcal{Q} \lhd \mathcal{R}) \equiv (\mathcal{P} \lhd \mathcal{Q}) \lhd \mathcal{R}}$
for all protocols $\mathcal{P}, \mathcal{Q}, \mathcal{R}$ where this expression is well defined.

$\txbf{Proof:}$
For the ideal functionalities, it's clear that by the associativity
of $\otimes$ for systems, the resulting functionality is the same
in both cases.

The trickier part of the proof is showing that the resulting players
are identical.

It's convenient to define a relation for the players in $\mathcal{R}$
that get used in $\mathcal{P}$ via the players in $\mathcal{Q}$.
To that end, we say that $\mathcal{P}.P_i$ \emph{uses} $\mathcal{R}.P_j$
if there exists $\mathcal{Q}.P_k$ such that $\mathcal{P}.P_i$ uses
$\mathcal{Q}.P_k$, and $\mathcal{Q}.P_k$ uses $\mathcal{R}.P_j$.

The players of $\mathcal{P} \lhd (\mathcal{Q} \lhd \mathcal{R})$ are of the form:
$$
  \mathcal{P}.P_i \circ
  \left( \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j \circ
  \left( \bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{Q}.P_j } \mathcal{R}.P_k
  \right)
  \right)
$$
While those in $(\mathcal{P} \lhd \mathcal{Q}) \mathcal{R}$ are of the form:
$$
  \left( \mathcal{P}.P_i \circ
  \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j
  \right)
  \circ
  \left(\bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{P}.P_i } \mathcal{R}.P_k
  \right)
$$
Now, we can apply the associativity of $\circ$ for systems, and also
group the $\mathcal{R}.P_k$ players based on which $\mathcal{Q}.P_j$ uses them:
$$
  \mathcal{P}.P_i \circ
  \left(
  \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j
  \right)
  \circ
  \left(
    \bigast_{\mathcal{Q}.P_j}
  \left(\bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{Q}.P_j } \mathcal{R}.P_k
  \right)
  \right)
$$
Now, the conditions are satisfied for applying the interchange lemma (Lemma~\ref{thm:interchange_system}),
giving us:
$$
  \mathcal{P}.P_i \circ
  \left( \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j \circ
  \left( \bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{Q}.P_j } \mathcal{R}.P_k
  \right)
  \right)
$$
Which is non other than the players in $\mathcal{P} \lhd (\mathcal{Q} \lhd \mathcal{R})$.

$\blacksquare$
\end{lemma}

\begin{definition}[Concurrent Composition]
Given two protocols $\mathcal{P}, \mathcal{Q}$,
we can define their concurrent composition---or tensor product---
$\mathcal{P} \otimes \mathcal{Q}$, provided a few requirements hold.
We require that:
\begin{enumerate}
\item $\tx{In}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset$.
\item $\tx{Out}(\mathcal{P}) \cap \tx{Out}(\mathcal{Q}) = \emptyset$.
\item $\tx{Out}(\mathcal{P}.F) \cap \tx{Out}(\mathcal{Q}.F) = \emptyset$ \emph{or} $\mathcal{P}.F = \mathcal{Q}.F$.
\item $\tx{Leakage}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset = \tx{Leakage}(\mathcal{Q}) \cap \tx{In}(\mathcal{P})$
\end{enumerate}

The players of $\mathcal{P} \otimes \mathcal{Q}$ consist of all the players
in $\mathcal{P}$ and $\mathcal{Q}$.
The ideal functionality is $\mathcal{P}.F \otimes \mathcal{Q}.F$, 
unless $\mathcal{P}.F = \mathcal{Q}.F$, in which case the ideal functionality
is simply $\mathcal{P}.F$.
This use of $\otimes$ is well defined by assumption.

The resulting protocol is also clearly well defined.

The jointly closed property holds because we've simply taken the union
of both player sets.

Since $\tx{In}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset$,
it also holds that for every $P_i, P_j$ in $\mathcal{P} \otimes \mathcal{Q}$,
we have $\tx{In}(P_i) \cap \tx{In}(P_j) = \emptyset$,
since each player comes from either $\mathcal{P}$ or $\mathcal{Q}$.
      
Finally, $\tx{Out}(\mathcal{P}) \cap \tx{Out}(\mathcal{Q}) = \emptyset$,
we have that $\tx{Out}(P_i) \cap \tx{Out}(P_j) = \emptyset$,
by the same reasoning.
    
$\square$
\end{definition}

\todo{The reason why we allow for $F = G$ is so that you can have like the same $1$}

\begin{lemma}
Concurrent composition is associative and commutative.
I.e. $\mathcal{P} \otimes (\mathcal{Q} \otimes \mathcal{R}) \equiv (\mathcal{P} \otimes \mathcal{Q}) \otimes \mathcal{R}$,
and $\mathcal{P} \otimes \mathcal{Q} \equiv \mathcal{Q} \otimes \mathcal{P}$ for
all protocols $\mathcal{P}, \mathcal{Q}, \mathcal{R}$ where these expressions
are well defined.

\txbf{Proof:}

By the definition of $\equiv$, all that matter is the \emph{set} of players,
and not their order.
Because $\cup$ is associative, and so is $\otimes$ for systems,
we conclude that concurrent composition is associative as well,
since the resulting set of players and ideal functionality are the same
in both cases.

Similarly, since $\cup$ and $\otimes$ (for systems) are commutative,
we conclude that concurrenty composition is commutative.

$\blacksquare$
\end{lemma}

\subsection{Corruption and Simulation}

\begin{definition}[``Honest'' Corruption]
Given a system $P$,
we define the ``honest'' corruption of $P$
$$
\tx{Corrupt}_H(P) := P
$$

This is clearly equality preserving, by tautology.

$\square$
\end{definition}

\begin{definition}[Semi-Honest Corruption]
Given a system $P$, we can define
the semi-honest corruption $\tx{Corrupt}_{\tx{SH}}(P)$.

This is a transformation of
of $P$, providing access to its ``view''.
More formally, $\tx{Corrupt}_{\tx{SH}}(P)$ is a system which works the same
as $P$, but with an additional public variable $\tx{log}$,
which contains several sub logs:
\begin{enumerate}
  \item $\tx{log}.{A_i}$ for each sending channel $A_i$,
  \item $\tx{log}.{B_i}$ for each receiving channel $B_i$,
  \item $\tx{log}.F$ for each input function $F$.
\end{enumerate}
Each of these sub logs is initialized with ${\tx{log}.\bullet \gets \tx{FifoQueue.New()}}$.
Additionally, $\tx{Corrupt}_{\tx{SH}}(P)$ modifies $P$ by pushing events to these
logs at different points in time.
These events are:
\begin{itemize}
\item $(\texttt{call}, (x_1, \ldots, x_n))$ to $\tx{log}.F$ when a function call $F(x_1, \ldots, x_n)$ happens.
\item $(\texttt{ret}, y)$ to $\tx{log}.F$ when the function $F$ returns a value $y$.
\item $m$ to $\tx{log}.A$ when a value $m$ is sent on channel $A$.
\item $m$ to $\tx{log}.B$ when a value $m$ is received on channel $B$.
\end{itemize}

This transformation is also equality respecting.
First, note that if $P = P'$ as systems, then
then $\tx{NoChan}(P) = \tx{NoChan}(P')$, and so their logs will be the same.

$\square$
\end{definition}

\begin{definition}[Malicious Corruption]
Given a system $P$ with:
$$
\begin{aligned}
  &\tx{In}(P) = \{F_1, \ldots, F_n\}\cr
  &\tx{OutChan}(P) = \{A_1, \ldots, A_m\}\cr
  &\tx{InChan}(P) = \{B_1, \ldots, B_l\}\cr
\end{aligned}
$$
we define the malicious corruption $\tx{Corrupt}_M(P)$ as the following game:
\package{$\tx{Corrupt}_M(P)$}{
&\underline{\tx{Call}_{F_i}((x_1, \ldots, x_n))\tx{:}}\cr
\pind{1} \preturn{F_i(x_1, \ldots, x_n)}\cr
\cr
&\underline{\tx{Send}_{A_i}(m)\tx{:}}\cr
\pind{1} \psend{m}{A_i}\cr
\cr
&\underline{\tx{Recv}_{B_i}()\tx{:}}\cr
\pind{1} \preturn{\precv{m}{B_i}}\cr
}

In other words, malicious corruption provides access to the functions
and channels used by $P$, but no more than that.

This is also equality preserving, since $\tx{Corrupt}_M(P)$ depends
only on the channels used by $P$ and the functions called by $P$,
all of which are the same for any $P' = P$.

$\square$
\end{definition}

\begin{lemma}[Simulating Corruptions]
  \label{thm:simulatingcorruption}
  We can simulate corruptions using strong forms of corruption.
  In particular, there exists systems $S_{\tx{SH}}$ and $S_{\tx{H}}$ such that
  for all systems $P$, we have:
  \[
    \begin{aligned}
      &\tx{Corrupt}_{\tx{SH}}(P) = S_{\tx{SH}} \circ \tx{Corrupt}_M(P)\cr
      &\tx{Corrupt}_{\tx{H}}(P) = S_{\tx{H}} \circ \tx{Corrupt}_{\tx{SH}}(P)
    \end{aligned}
  \]

\txbf{Proof:}
For the simulation of honest corruption, we can simply ignore
  the additional log variable, and set $S_{\tx{H}} := 1(\tx{Out}(P))$.

For semi-honest corruption, $S_{\tx{SH}}$ is formed by first transforming
$\tx{Corrupt}_{\tx{SH}}(P)$, replacing:
\begin{itemize}
  \item every function call with $\tx{Call}_{F_i}(\ldots)$,
  \item every sending of a message $m$ on $A$ with $\tx{Send}_A(m)$,
  \item every reception of a message on $B$ with $\tx{Recv}_B()$.
\end{itemize}
This results in a system $S'$, which we then compose to get:
$$
S_{\tx{SH}} :=
\begin{pmatrix}
  S'\cr
  \otimes\cr
  1(\{\tx{Next}\})
\end{pmatrix}
\circ
\begin{pmatrix}
\tx{SharedRand}\cr
\otimes\cr
1(\tx{In}(S'))
\end{pmatrix}
$$

The result is clearly a perfect emulation of semi-honest corruption
using malicious corruption.

$\blacksquare$
\end{lemma}

Sometimes, it's useful to be able to talk about corruptions in general,
in which case we write $\text{Corrupt}_\kappa(P)$,
for $\kappa \in \{\tx{H}, \tx{SH}, \tx{M}\}$.

\begin{definition}[Corruption Models]
Given a protocol $\mathcal{P}$ with players $P_1, \ldots, P_n$, a \emph{corruption model} $C$
is a function $C : [\mathcal{P}.n] \to \{\tx{H}, \tx{SH}, \tx{M}\}$.
This provides a corruption $C_i$ associated with each player $P_i$.
We can then define $\text{Corrupt}_C(P_i) := \text{Corrupt}_{C_i}(P_i)$.

Corruption models have a natural partial order associated with them. 
We have:
$$
\tx{H} < \tx{SH} < \tx{M}
$$
  and then we say that $C \geq C'$ if $\forall i \in [n]. \quad C_i \geq C'_i$.

A \emph{class of corruptions} $\mathcal{C}$ is simply a set of corruption models.

$\square$
\end{definition}

Some common classes are:
\begin{itemize}
  \item The class of malicious corruptions, where all but one player is malicious.
  \item The class of malicious corruptions, where all but one player is semi-honest.
\end{itemize}

\begin{definition}[Instantiation]
  Given a closed protocol $\mathcal{P}$ and a corruption model $C$, we can
  define an \emph{instantiation} $\tx{Inst}_C(\mathcal{P})$, which
  is a system defining the semantics of the protocol.

  First, we need to define a transformation of systems to use
  a \emph{router} $\mathcal{R}$, which will be a special system
  allowing an adversary to control the order of delivery of messages.

  Let $\{A_1, \ldots, A_n\} = \tx{Chan}(P_1, \ldots, P_n)$.
  We then define $\mathcal{R}$ as the syten:
\package{$\mathcal{R}$}{
&\underline{\tx{Deliver}_{A_i}()\tx{:}}\cr
\pind{1} \precv{m}{\langle A_i, \mathcal{R} \rangle}\cr
\pind{1} \psend{m}{\langle \mathcal{R}, A_i \rangle}\cr
}

  Next, we define a transformation $\tx{Routed}(S)$ of a system,
  which makes communication pass via the router:
  \begin{itemize}
    \item Whenever $S$ sends $m$ via $A$, $\tx{Routed}(S)$ sends $m$ via $\langle A , \mathcal{R} \rangle$.
    \item Whenever $S$ receives $m$ via $B$, $\tx{Routed}(S)$ recieves $m$ via $\langle \mathcal{R}, B \rangle$.
  \end{itemize}

With this in hand, we define:
$$
\tx{Inst}_C(\mathcal{P}) :=
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [n]} \tx{Routed}(\tx{Corrupt}_C(P_i))\cr
    *\cr
    \mathcal{R}\cr
    \otimes\cr
    1(\tx{Leakage})
  \end{pmatrix}
  \circ F
$$


$\square$
\end{definition}

\begin{lemma}[Properties of $\tx{Routed}$]
  \label{thm:routed}
  For any systems $A, B$, we have:
$$
\begin{aligned}
  &\tx{Routed}(A \circ B) = \tx{Routed}(A) \circ \tx{Routed}(B)\cr
  &\tx{Routed}(A * B) = \tx{Routed}(A) * \tx{Routed}(B)\cr
  &\tx{Routed}(A \otimes B) = \tx{Routed}(A) \otimes \tx{Routed}(B)\cr
\end{aligned}
$$
(provided these expressions are well defined)

\txbf{Proof:} The $\tx{Routed}$ transformation simply
renames each sending and receiving channel in a system.
In all the cases above, even $A * B$, all of the channels present
in $A$ and $B$ are present in the composition, and so all
of these equations hold.

$\blacksquare$
\end{lemma}


\begin{definition}[Associated Corruption Classes]
\label{def:assoccc}
Given two protocols $\mathcal{P}, \mathcal{Q}$ where $\otimes$ is well
defined, a corruption class $\mathcal{C}$ for $\mathcal{Q}$ has a natural
corruption class $\mathcal{C}'$ for $\mathcal{P} \otimes \mathcal{Q}$.

For each model $C \in \mathcal{C}$, the resulting $\mathcal{C}'$ will
contain a model for each possible honest corruption of the players
in $P$ with efficient agents $A_1, \ldots$.
In other words, the corruptions in this class will be those of $\mathcal{C}$,
with $\mathcal{P}$ always behaving honestly.


We can also do the same for $\mathcal{P} \circ \mathcal{Q}$,
but the corruption class $\mathcal{C}'$ is a bit trickier.
We say that a corruption model $C$ for $\mathcal{P}$ is compatible with
a corruption model $C'$ for $\mathcal{Q}$ if for every
$\mathcal{Q}.P_j$ used by $\mathcal{P}.P_i$, the corruption
level of $\mathcal{Q}.P_j$ in $\mathcal{C}'$ is $\geq$ the corruption level of $\mathcal{P}.P_i$
in $\mathcal{C}$.
A corruption model $C$ for $\mathcal{P}$ is compatible
with a \emph{class} of corruptions $\mathcal{C}$, if
there exists a compatible model $C'$ in $\mathcal{C}$.

With this in hand, the corruption class $\mathcal{C}'$ for $\mathcal{P} \circ \mathcal{Q}$
is the largest (closed) corruption class $\mathcal{C}'$ for $\mathcal{P}$ such
that each $C \in \mathcal{C}'$ is compatible with $\mathcal{C}$.
Because of the definition of $\circ$, a corruption model
for $\mathcal{P}$ naturally yields a model for $\mathcal{P} \circ \mathcal{Q}$,
so this is well defined.


$\square$
\end{definition}

\begin{definition}[Compatible Corruptions]
  Given protocols $\mathcal{P}, \mathcal{Q}$, and a corruption model
  $C$ for $\mathcal{Q}$, we can define a notion of a \emph{compatible}
  corruption model $C'$ for $\mathcal{P} \otimes \mathcal{Q}$ or $\mathcal{P} \circ \mathcal{Q}$,
  provided these expressions are well defined.

  A corruption model $C'$ for $\mathcal{P} \otimes \mathcal{Q}$.
  is compatible with $C$ when every corruption of a player
  in $\mathcal{Q}$ is $\geq$ that of the corresponding corruption in $C$.

  We say that a corruption model $C'$ for $\mathcal{P} \circ \mathcal{Q}$ is compatible with
a corruption model $C$ for $\mathcal{Q}$ if for every
$\mathcal{Q}.P_j$ used by $\mathcal{P}.P_i$, the corruption
level of $\mathcal{Q}.P_j$ in $\mathcal{C}'$ is $\geq$ the corruption level of $\mathcal{P}.P_i$
in $\mathcal{C}$.

  This extends to corruption \emph{classes} as well.
  A corruption class $\mathcal{C}'$ is compatible with a class $\mathcal{C}$,
  if for every $C \in \mathcal{C}$ there exists a compatible $C' \in \mathcal{C}'$.

  $\square$
\end{definition}

\begin{theorem}[Concurrent Breakdown]
  Given protocols $\mathcal{P}, \mathcal{Q}$, and a corruption model $C$
  for $\mathcal{Q}$, then for any corruption model $C'$ for $\mathcal{P} \otimes \mathcal{Q}$ compatible with $C$, we have:
  \[
    \tx{Inst}_{C'}(\mathcal{P} \otimes \mathcal{Q}) = \tx{Inst}_{C'}(\mathcal{P}) \otimes \tx{Inst}_C(\mathcal{Q})
  \]
\txbf{Proof:} If we unroll $\text{Inst}_{C'}(\mathcal{P} \otimes \mathcal{Q})$, we get:
$$
\begin{pmatrix}
\mathcal{R}\cr
*\cr
\left(\bigast_{i \in [\mathcal{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{P}.P_i))\right)\cr
*\cr
\left(\bigast_{i \in [\mathcal{Q}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{Q}.P_i))\right)\cr
\otimes\cr
1(\mathcal{P}.\tx{Leakage}, \mathcal{Q}.\tx{Leakage})
\end{pmatrix}
\circ
\begin{pmatrix}
\mathcal{P}.F\cr
\otimes\cr
\mathcal{Q}.F\cr
\end{pmatrix}
$$

We can apply a few observations here:
\begin{enumerate}
  \item Since $\mathcal{C}'$ is compatible with $\mathcal{C}$, then $\mathcal{Q}.P_i$ follows a corruption from $\mathcal{C}$.
  \item $\mathcal{R}$ can be written as $\mathcal{R}_\mathcal{P} \otimes \mathcal{R}_\mathcal{Q}$,
  with one system using channels in $\mathcal{P}$, and the other using channels in $\mathcal{Q}$.
  \item Since protocols are closed, we can use $\otimes$ between the players in $\mathcal{P}$ and $\mathcal{Q}$,
  since they never send messages to each other.
\end{enumerate}
This results in the following:
$$
\begin{pmatrix}
  \mathcal{R}_{\mathcal{P}} * \left(\bigast_{i \in [\mathcal{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{P}.P_i))\right) \otimes 1(\mathcal{P}.\tx{Leakage})\cr
\otimes\cr
  \mathcal{R}_{\mathcal{Q}} * \left(\bigast_{i \in [\mathcal{Q}.n]} \tx{Routed}(\tx{Corrupt}_{C}(\mathcal{Q}.P_i))\right) \otimes 1(\mathcal{Q}.\tx{Leakage})
\end{pmatrix}
\circ
\begin{pmatrix}
\mathcal{P}.F\cr
\otimes\cr
\mathcal{Q}.F\cr
\end{pmatrix}
$$
From here, we apply Lemma~\ref{thm:interchange_system} (interchange), to get:
$$
\begin{matrix}
\tx{Inst}_{C'}(\mathcal{P})\cr
\otimes\cr
\tx{Inst}_{C}(\mathcal{Q})\cr
\end{matrix}
$$

$\blacksquare$

\end{theorem}

\begin{theorem}[Horizontal Breakdown]
  Given protocols $\mathcal{P}, \mathcal{Q}$, and a corruption
  model $C$ for $\mathcal{Q}$, then for any compatible corruption
  model $C'$ for $\mathcal{P} \lhd \mathcal{Q}$, there exists
  systems $S_1, \ldots, S_{\mathcal{Q}.n}$ and a set $L_{\mathcal{Q}}$ such that:
  $$
  \tx{Inst}_{C'}(\mathcal{P} \lhd \mathcal{Q}) =
  1(O)\circ
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [\mathcal{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{P}.P_i))
    \cr
    *\cr
    \mathcal{R}_{\mathcal{P}}\cr
    \otimes\cr
    1(\tx{Leakage}, L_{\mathcal{Q}})
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \mathcal{P}.F\cr
    \otimes\cr
    1(\tx{Out}(\mathcal{R}_q))\cr
    \otimes\cr
    1(\mathcal{Q}.\tx{Leakage})\cr
    \otimes\cr
    \bigotimes_{i \in [\mathcal{Q}.n]} S_i\cr
  \end{pmatrix}
  \circ
  \tx{Inst}_C(\mathcal{Q})
  $$
  where $O := \tx{Out}(\tx{Inst}_{C'}(\mathcal{P} \lhd \mathcal{Q}))$,
  and $\mathcal{R}_{\mathcal{P}} \circ \mathcal{R}_{\mathcal{Q}} = \mathcal{R}$
  are a decomposition of the router $\mathcal{R}$ for $\mathcal{P} \lhd \mathcal{Q}$.

\txbf{Proof:} We start by unrolling $\tx{Inst}_{C'}(\mathcal{P} \lhd \mathcal{Q})$,
to get:
\[
\tx{Inst}_C(\mathcal{P} \lhd \mathcal{Q}) =
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [\mathcal{P}.n]} \tx{Routed}\left(\tx{Corrupt}_{C'}\left(\mathcal{P}.P_i \circ 
        \left( \bigast_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i} \mathcal{Q}.P_j \right)
    \right)\right)\cr
    *\cr
    \mathcal{R}\cr
    \otimes\cr
    1(\tx{Leakage})
  \end{pmatrix}
  \circ \begin{pmatrix}
    \mathcal{P}.F\cr
    \otimes \cr
    \mathcal{Q}.F
  \end{pmatrix}
\]
Our strategy will be to progressively build up an equivalent system
to this one, starting with $\tx{Corrupt}_C$, then $\tx{Routed}$, etc.

First, some observations about $\tx{Corrupt}_\kappa(P \circ (Q_1 * \cdots))$.

In the case of malicious corruption, we have:
$$
\tx{Corrupt}_M(P \circ (Q_1 * \cdots * Q_m)) =
1(O) \circ
\begin{pmatrix}
  \tx{Corrupt}_M(P)\cr
  \otimes\cr
  1(\tx{Out}(\tx{Corrupt}_M(Q_1)), \ldots)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
  \tx{Corrupt}_M(Q_1)\cr
  *\cr
  \cdots\cr
  *\cr
  \tx{Corrupt}_M(Q_m)\cr
\end{pmatrix}
$$
for $O = \tx{Out}(\tx{Corrupt}_M(P \circ (Q_1 * \cdots)))$.
This holds by definition, since corruption $P \circ (Q_1 * \cdots)$ precisely allows
sending messages on behalf of $P$ or any $Q_i$, as well as calling
the input functions to the $Q_i$ systems.
We can write this expression more concisely,
using $1(L^M)$ for $L^M = \tx{Out}(\tx{Corrupt}_M(Q_1)) \cup \cdots$.

Next, we look at semi-honest corruption.
Because the logs are divided into independent sub logs, we can write:
$$
\tx{Corrupt}_{\tx{SH}}(P \circ (Q_1 * \cdots * Q_m)) =
1(O) \circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{SH}}(P)\cr
  \otimes\cr
  1(\{Q_1.\tx{log}, \ldots\})
\end{pmatrix}
\circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{SH}}(Q_1)\cr
  *\cr
  \cdots
\end{pmatrix}
$$
where $O = \tx{Out}(\tx{Corrupt}_{\tx{SH}}(P \circ (Q_1 * \cdots)))$

And for honest corruption, we have
$$
\tx{Corrupt}_{\tx{H}}(P \circ (Q_1 * \cdots)) = P \circ (Q_1 * \cdots)
$$

Now, the compatibility condition of $C'$ relative to $C$
does not guarantee that if $\mathcal{P}.P_i$ uses $\mathcal{Q}.P_j$,
then $\mathcal{Q}.P_j$ has the same level of corruption: 
it only guarantees a level of corruption at least as strong.
By Lemma~\ref{thm:simulatingcorruption}, we can simulate a weaker
form of corruption using a stronger form, via some simulator system $S$,
depending on the levels of corruption.

Using these simulators, we get, slightly different results based
on the level of corruption.

When $C'_i = \tx{M}$:
$$
\tx{Corrupt}_{C'}((\mathcal{P} \lhd \mathcal{Q}).P_i) =
1(O_i) \circ
\begin{pmatrix}
  \tx{Corrupt}_{C'}(\mathcal{P}.P_i)\cr
  \otimes\cr
  1(L_i)\cr
\end{pmatrix}
\circ
\left(
\bigast_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i}
  \tx{Corrupt}_C(\mathcal{Q}.P_j)
\right)
$$
with $O_i = \tx{Out}(\tx{Corrupt}_{C'}(\mathcal{P} \lhd \mathcal{Q}).P_i)$, $L_i= \bigcup_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i} \tx{Out}(\tx{Corrupt}_M(\mathcal{Q}.P_j))$.
No simulation is needed, since the compatibility of $C'$ with $C$
guarantees that all of the players used by $\mathcal{P}.P_i$
are maliciously corrupted.

When $C'_i = \tx{SH}$:
$$
\tx{Corrupt}_{C'}((\mathcal{P} \lhd \mathcal{Q}).P_i) =
1(O_i) \circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{C'}}(P)\cr
  \otimes\cr
  1(L_i)
\end{pmatrix}
\circ
\left(
\bigast_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i}
  S_j \circ \tx{Corrupt}_C(\mathcal{Q}.P_j)
\right)
$$
with $O_i = \tx{Out}(\tx{Corrupt}_{C'}(\mathcal{P} \lhd \mathcal{Q}).P_i)$,
$L_i = \{\mathcal{Q}.P_j.\tx{log} \mid \mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i \}$,
and $S_j$ depending on the level of corruption for $\mathcal{Q}.P_j$ in $C$:
\begin{itemize}
  \item $S_j = S_{\tx{SH}}$ if $C_j = \tx{M}$
  \item $S_j = 1$ if $C_j = \tx{SH}$
\end{itemize}

When $C'_i = \tx{H}$:
$$
\tx{Corrupt}_{C'}((\mathcal{P} \lhd \mathcal{Q}).P_i) =
  \tx{Corrupt}_{\tx{C'}}(P)
\circ
\left(
\bigast_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i}
  S_j \circ \tx{Corrupt}_C(\mathcal{Q}.P_j)
\right)
$$
with $S_j$ depending on the level of corruption for $\mathcal{Q}.P_j$ in $C$:
\begin{itemize}
  \item $S_j = S_{\tx{H}} \circ S_{\tx{SH}}$ if $C_j = \tx{M}$
  \item $S_j = S_{\tx{H}}$ if $C_j = \tx{SH}$
  \item $S_j = 1$ if $C_j = \tx{H}$
\end{itemize}

We can unify these three cases, writing:
$$
\tx{Corrupt}_{C'}((\mathcal{P} \lhd \mathcal{Q}).P_i) =
1(O_i) \circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{C'}}(P)\cr
  \otimes\cr
  1(L_i)
\end{pmatrix}
\circ
\left(
\bigast_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i}
  S_j \circ \tx{Corrupt}_C(\mathcal{Q}.P_j)
\right)
$$
with $O_i$ and $L_i$ depending on the corruption level of $\mathcal{P}.P_i$,
and $S_j$ depending on the corruption levels of both $\mathcal{P}.P_i$
and $\mathcal{Q}.P_j$.

By the properties of $\tx{Routed}$ (Lemma~\ref{thm:routed}), we have:
$$
\begin{aligned}
&\tx{Routed}(\tx{Corrupt}_{C'}((\mathcal{P} \lhd \mathcal{Q}).P_i)) =\cr
&1(O_i) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}_{\tx{C'}}(P))\cr
  \otimes\cr
  1(L_i)
\end{pmatrix}
\circ
\left(
\bigast_{\mathcal{Q}.P_j \tx{ used by } \mathcal{P}.P_i}
  S_j \circ \tx{Routed}(\tx{Corrupt}_C(\mathcal{Q}.P_j))
\right)
\end{aligned}
$$

Next, we need to add the router $\mathcal{R}$.
We note that since $\mathcal{P}$ and $\mathcal{Q}$ have separate channels,
we can write $\mathcal{R} = \mathcal{R}_{\mathcal{P}} \circ \mathcal{R}_{\mathcal{Q}}$,
where the latter contains only the channels in $\mathcal{Q}$,
and the former contains the channels in $\mathcal{P}$,
and provides access to those in $\mathcal{Q}$ via its function dependencies.
Combing this with the interchange lemma, we get:
$$
\begin{aligned}
&\mathcal{R} * \bigast_{i \in [\mathcal{P}.n]}\tx{Routed}(\tx{Corrupt}_{C'}((\mathcal{P} \lhd \mathcal{Q}).P_i)) * \mathcal{R} =\cr
&1(\tx{Out}(\mathcal{R}), O_1, \ldots, O_{\mathcal{P}.n}) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}_{\tx{C'}}(P))\cr
  *\cr
  \mathcal{R}_{\mathcal{P}}\cr
  \otimes\cr
  1(L_1, \ldots, L_{\mathcal{P}.n})
\end{pmatrix}
\circ
\begin{pmatrix}
\bigast_{j \in [\mathcal{Q}.n]}
  S_j \circ \tx{Routed}(\tx{Corrupt}_C(\mathcal{Q}.P_j))
  \cr
  *\cr
  \mathcal{R}_{\mathcal{Q}}
\end{pmatrix}
\end{aligned}
$$

All that remains is to add the ideal functionalities, giving us,
after application of the interchange lemma:
$$
\begin{aligned}
  &\tx{Inst}_{C'}(\mathcal{P} \lhd \mathcal{Q}) =\cr
&1(O) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}_{\tx{C'}}(P))\cr
  *\cr
  \mathcal{R}_{\mathcal{P}}\cr
  \otimes\cr
  1(\tx{Leakage}, L_{\mathcal{Q}})
\end{pmatrix}
\circ
\begin{pmatrix}
\bigast_{j \in [\mathcal{Q}.n]}
  S_j \circ \tx{Routed}(\tx{Corrupt}_C(\mathcal{Q}.P_j))
  \cr
  *\cr
  \mathcal{R}_{\mathcal{Q}}\cr
  \otimes\cr
  1(\tx{Leakage})
\end{pmatrix}
\circ
\begin{pmatrix}
  \mathcal{P}.F\cr
  \otimes\cr
  \mathcal{Q}.F
\end{pmatrix}
\end{aligned}
$$
with $O := \tx{Out}(\tx{Inst}_{C'}(\mathcal{P} \lhd \mathcal{Q}))$,
and $L_{\mathcal{Q}} := \bigcup_{i \in [\mathcal{P}.n]} L_i$.

Now, because $\mathcal{Q}$ does not use any of the functions
in $\mathcal{P}.F$, and because each simulator $S_j$
does not use any channels, we can rewrite this as:
$$
1(O) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}_{\tx{C'}}(P))\cr
  *\cr
  \mathcal{R}_{\mathcal{P}}\cr
  \otimes\cr
  1(\tx{Leakage}, L_{\mathcal{Q}})
\end{pmatrix}
\circ
\begin{pmatrix}
  \mathcal{P}.F\cr
  \otimes\cr
  1(\tx{Out}(\mathcal{R}_{\mathcal{Q}}))\cr
  \otimes\cr
  1(\mathcal{Q}.\tx{Leakage})\cr
  \otimes\cr
  \bigotimes_{j \in [\mathcal{Q}.n]} S_j
\end{pmatrix}
\circ
\begin{pmatrix}
\bigast_{j \in [\mathcal{Q}.n]}
  \tx{Routed}(\tx{Corrupt}_C(\mathcal{Q}.P_j))
  \cr
  *\cr
  \mathcal{R}_{\mathcal{Q}}\cr
  \otimes\cr
  1(\mathcal{Q}.\tx{Leakage})
\end{pmatrix}
\circ
  \mathcal{Q}.F
$$

We can then notice that the right hand side of this equation
is simply $\tx{Inst}_C(\mathcal{Q})$,
concluding our proof.

$\blacksquare$

\end{theorem}

\subsection{Equality and Simulation}

\begin{definition}[Shape]
  \label{def:shape}
  We say that two protocols $\mathcal{P}, \mathcal{Q}$ have the same \emph{shape}
  if there exists a protocol $\mathcal{Q}' \equiv \mathcal{Q}$ such that:
  \begin{itemize}
    \item $\mathcal{P}.n = \mathcal{Q}'.n$,
    \item $\forall i \in [n].\quad \tx{In}(\mathcal{P}.P_i) = \tx{In}(\mathcal{Q}'.Q_i)$,
    \item $\forall i \in [n].\quad \tx{Out}(\mathcal{P}.P_i) = \tx{Out}(\mathcal{Q}'.Q_i)$,
    \item $\tx{Leakage}(\mathcal{P}) = \tx{Leakage}(\mathcal{Q}')$,
    \item $\tx{IdealIn}(\mathcal{P}) = \tx{IdealIn}(\mathcal{Q}')$.
  \end{itemize}

  $\square$
\end{definition}

\begin{definition}[Semantic Equality]
  We say that two closed protocols $\mathcal{P}$ and $\mathcal{Q}$,
  with the same shape,
  are equal under a class of corruptions $\mathcal{C}$,
  written as $\mathcal{P} =_{\mathcal{C}} \mathcal{Q}$, when we have:
  $$
  \forall C \in \mathcal{C}.\quad \tx{Inst}_C(\mathcal{P}) = \tx{Inst}_C(\mathcal{Q'})
  $$
  as systems, with $\mathcal{Q}' \equiv \mathcal{Q}$ as per 
  Definition~\ref{def:shape}.

  $\square$

\end{definition}

\begin{definition}[Indistinguishability]
  We say that two closed protocols $\mathcal{P}$ and $\mathcal{Q}$,
  with the same shape,
  are \emph{indistinguishable} up to $\epsilon$ under a class of corruptions $\mathcal{C}$,
  written as $\mathcal{P} \overset{\epsilon}{\approx}_{\mathcal{C}} \mathcal{Q}$, when we have:
  $$
  \forall C \in \mathcal{C}.\quad \tx{Inst}_C(\mathcal{P}) \overset{\epsilon}{\approx} \tx{Inst}_C(\mathcal{Q'})
  $$
  as systems, with $\mathcal{Q}' \equiv \mathcal{Q}$ as per 
  Definition~\ref{def:shape}.

  $\square$

\end{definition}

\begin{definition}[Simulated Instantiation]
  A simulator $S$ for a closed protocol $\mathcal{P}$ under a corruption
  model $C$ consists of a system $S_\tx{Leakage}$,
  as well as systems $S_i$ for each
  $\mathcal{P}.P_i$ with $C_i \neq \tx{H}$.
  These must satisfy:
  \begin{itemize}
    \item $\tx{In}(S_{\tx{Leakage}}), \tx{Out}(S_{\tx{Leakage}}) = \tx{Leakage}$,
    \item when $C_i = \tx{M}$, $\tx{In}(S_i) = \tx{In}(\mathcal{P}.P_i)$, $\tx{(In/Out)Chan}(S_i) = \tx{(In/Out)Chan}(P_i)$,
    \item when $C_i = \tx{SH}$, $\tx{In}(S_i) = \tx{Out}(\tx{Corrupt}_{\tx{SH}}(\mathcal{P}.P_i))$, $\tx{Chan}(S_i) = \emptyset$,
    \item $\tx{Out}(S_i) = \tx{Out}(\tx{Corrupt}_{C_i}(\mathcal{P}.P_i))$.
  \end{itemize}

  Given such a simulator, we can define the simulated instantiation
  of $\mathcal{P}$ under $C$ with $S$ as:
  $$
  \tx{SimInst}_{S, C}(\mathcal{P}) := 
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [n],\ C_i = \tx{M}} \tx{Routed}(S_i)\cr
    *\cr
    {\displaystyle \bigast}_{i \in [n],\ C_i = \tx{SH}} \tx{Routed}(S_i \circ \tx{Corrupt}_{\tx{SH}}(P_i))\cr
    *\cr
    {\displaystyle \bigast}_{i \in [n],\ C_i = \tx{H}} \tx{Routed}(P_i)\cr
    *\cr
    \mathcal{R}\cr
    \otimes\cr
    S_\tx{Leakage}
  \end{pmatrix}
  \circ F
  $$

  $\square$
\end{definition}

\begin{definition}[Simulatability]
  Given closed protocols $\mathcal{P}, \mathcal{Q}$ with the same shape,
  we say that $\mathcal{P}$ is \emph{simulatable} up to $\epsilon$ by $\mathcal{Q}$
  under a class of corruptions $\mathcal{C}$,
  written as $\mathcal{P} \overset{\epsilon}{\leadsto}_{\mathcal{C}} \mathcal{Q}$,
  when:
  $$
  \forall C \in \mathcal{C}.\exists S.\quad \tx{Inst}_C(\mathcal{P}) \overset{\epsilon}{\approx} \tx{SimInst}_{S, C}(\mathcal{Q}')
  $$
  as systems, with $\mathcal{Q}' \equiv \mathcal{Q}$ as per 
  Definition~\ref{def:shape}.

  $\square$
\end{definition}

\begin{theorem}[Equality Hierarchy]
For any corruption class $\mathcal{C}$, we have:
\begin{enumerate}
\item $\mathcal{P} \equiv \mathcal{Q} \implies \mathcal{P} =_\mathcal{C} \mathcal{Q}$.
\item $\mathcal{P} =_{\mathcal{C}} \mathcal{Q} \implies \mathcal{P} \overset{0}{\approx}_\mathcal{C} \mathcal{Q}$.
\item $\mathcal{P} \overset{\epsilon}{\approx}_{\mathcal{C}} \mathcal{Q} \implies \mathcal{P} \overset{\epsilon}{\leadsto}_\mathcal{C} \mathcal{Q}$.
\end{enumerate}

\txbf{Proof:}

\txbf{1.} 
For any $C \in \mathcal{C}$, $\tx{Corrupt}_{C}$ and $\tx{Routed}$ are equality respecting,
so we have:
$$
\forall i \in [n].\quad \tx{Routed}(\tx{Corrupt}_C(\mathcal{P}.P_i)) = 
\tx{Routed}(\tx{Corrupt}_C(\mathcal{Q}.P_i))
$$

Furthermore, the equality of players between $\mathcal{P}$ and $\mathcal{Q}$
makes $\mathcal{P}.\mathcal{R} = \mathcal{Q}.\mathcal{R}$.

And then, the fact that $\mathcal{P}.F = \mathcal{Q}.F$ forces $\tx{Leakage}$
to be the same as well.

Finally, since $\circ, *, \otimes$ are equality respecting, we
can clearly see that $\tx{Inst}_C(\mathcal{P}) = \tx{Inst}_C(\mathcal{Q})$,
since all the sub-components are equal.

\txbf{2.} For any systems $A, B$, we have $A = B \implies A \overset{0}{\approx} B$.
Applying this to $\tx{Inst}_C(\mathcal{P})$ and $\tx{Inst}_C(\mathcal{Q})$
gives us our result.

\txbf{3.} It suffices to define a simulator $S$ such that
$\tx{SimInst}_{S, C}(\mathcal{Q}) = \tx{Inst}_C(\mathcal{Q})$,
which will then show our result.

We define this simulator as:
\begin{itemize}
  \item $S_{\tx{Leakage}} = 1(\tx{Leakage})$.
  \item $S_i = \tx{Corrupt}_{\tx{M}}(P_i)$, when $C_i = \tx{M}$.
  \item $S_i = 1(\tx{Out}(\tx{Corrupt}_{\tx{SH}}(P_i)))$, when $C_i = \tx{SH}$.
\end{itemize}
which clearly does the same thing as instantiation.

$\blacksquare$
\end{theorem}

\begin{theorem}[Vertical Composition Theorem]
  For any protocol $\mathcal{P}$ and game $G$, such that $\mathcal{P} \circ G$
  is well defined and closed, and for any corruption class $\mathcal{C}$, we have:
  \begin{enumerate}
    \item $G = G' \implies \mathcal{P} \circ G = \mathcal{P} \circ G'$
    \item $G \overset{\epsilon}{\approx} G' \implies \mathcal{P} \circ G \overset{\epsilon}{\approx} \mathcal{P} \circ G'$
  \end{enumerate}
  
\txbf{Proof:} \todo{todo}
\end{theorem}

\begin{theorem}[Concurrent Composition Theorem]
  For any protocols $\mathcal{P}, \mathcal{Q}$, with $\mathcal{P} \otimes \mathcal{Q}$
  well defined and closed, and for any corruption class $C$, we have:
  \begin{enumerate}
    \item $\mathcal{Q} \equiv \mathcal{Q}' \implies \mathcal{P} \otimes \mathcal{Q} \equiv \mathcal{P} \otimes \mathcal{Q}'$
    \item $\mathcal{Q} = \mathcal{Q}' \implies \mathcal{P} \otimes \mathcal{Q} = \mathcal{P} \otimes \mathcal{Q}'$
    \item $\mathcal{Q} \overset{\epsilon}{\approx} \mathcal{Q}' \implies \mathcal{P} \otimes \mathcal{Q} \overset{\epsilon}{\approx} \mathcal{P} \otimes \mathcal{Q}'$
    \item $\mathcal{Q} \overset{\epsilon}{\leadsto} \mathcal{Q}' \implies \mathcal{P} \otimes \mathcal{Q} \overset{\epsilon}{\leadsto} \mathcal{P} \otimes \mathcal{Q}'$
  \end{enumerate}

  \txbf{Proof:} \todo{todo}
\end{theorem}

\begin{theorem}[Horizontal Composition Theorem]
  For any protocols $\mathcal{P}, \mathcal{Q}$ with $\mathcal{P} \lhd \mathcal{Q}$
  well defined and closed, and for any corruption class $C$, we have:
  \begin{enumerate}
    \item $\mathcal{Q} \equiv \mathcal{Q}' \implies \mathcal{P} \lhd \mathcal{Q} \equiv \mathcal{P} \lhd \mathcal{Q}'$
    \item $\mathcal{Q} = \mathcal{Q}' \implies \mathcal{P} \lhd \mathcal{Q} = \mathcal{P} \lhd \mathcal{Q}'$
    \item $\mathcal{Q} \overset{\epsilon}{\approx} \mathcal{Q}' \implies \mathcal{P} \lhd \mathcal{Q} \overset{\epsilon}{\approx} \mathcal{P} \lhd \mathcal{Q}'$
    \item $\mathcal{Q} \overset{\epsilon}{\leadsto} \mathcal{Q}' \implies \mathcal{P} \lhd \mathcal{Q} \overset{\epsilon}{\leadsto} \mathcal{P} \lhd \mathcal{Q}'$
  \end{enumerate}

  \txbf{Proof:} \todo{todo}
\end{theorem}

\section{Protocols}

The goal of this section will be to define \emph{protocols},
along with ways to compose and compare protocols.
Intuitively, a protocol is a kind of algorithm involving several
players, cooperating together to achieve a desired goal.
The protocol specifies how each player should behave.

The first way of composing protocols we look at is concurrent composition,
which lets us run two protocols involving separate players in parallel,
with on interaction between them.
The second way of composing protocols is more interesting.
We can have one protocol invoke another as a sub-protocol,
with each player in the first playing the role of several players
in the latter.
These two operations are useful in tandem, allowing
us to decompose large protocols into smaller ones,
allowing for modular reasoning.

When it comes to the equality of protocols,
the preferred notion is that of simulation,
which we'll explain in more detail later.
For now, the basic idea is that simulation
turns attacks on one protocol into attacks on the other.
Beyond just simulation, we also define two stronger
notions of equality,
which allow describing the fact that two protocols behave exactly the same,
or almost the same, even without simulation.

This section follows the basic road map we've used for both packages
and systems.
We first define what protocols are formally, as well as the ways
in which they compose.
We then define notions of corruption, and then define the semantics
of protocols, based on which participants in the protocol
are corrupted.
Finally, we define notions of equality for protocols,
and explore the ways in which these notions are preserved under composition.

\subsection{Defining Protocols and Composition}

We start by definition protocols.
All of the work we expended in defining systems was ultimately
to describe protocols,
so naturally we'll be using systems again here.
The basic idea is that each player is described by a system,
and also that the players have access to a package,
representing the ideal functionality of the protocol,
if any.
Rather than considering ``real'' and ``ideal'' world protocols,
we only ever consider protocols in the hybrid model.

\begin{definition}[Protocols]
A \emph{protocol} $\mathscr{P}$ consists of:
\begin{itemize}
\item Systems $P_1, \ldots, P_n$, called \emph{players},
\item An asynchronous package $F$, called the \emph{ideal functionality},
\item A set $\tx{Leakage} \subseteq \tx{Out}(F)$, called the \emph{leakage}.
\end{itemize}

Furthermore, we also impose requirements on the channels and functions
these elements use.

First, we require that the player systems are jointly closed,
with no extra channels that aren't connected to other players:
$$
\bigcup_{i \in [n]} \text{OutChan}(P_i) = \bigcup_{i \in [n]} \text{InChan}(P_i)
$$

Second, we require that the functions the systems depend on are disjoint,
outside of the ideal functionality:
$$
\forall i, j \in [n].\quad \text{In}(P_i) \cap \text{In}(P_j) \subseteq \tx{Out}(F)
$$

Third, we require that the functions the systems export on are disjoint:
$$
\forall i, j \in [n].\quad \text{Out}(P_i) \cap \text{Out}(P_j) = \emptyset
$$

We can also define a few convenient notations related to the interface of a base
protocol.

Let $\text{Out}_i(\mathscr{P}) := \text{Out}(P_i)$, and let $\text{In}_i(\mathscr{P}) := \text{In}(P_i) / \text{Out}(F)$.
We then define:
\begin{itemize}
  \item $\text{Out}(\mathscr{P}) := \bigcup_{i \in [n]} \text{Out}_i(\mathscr{P})$,
  \item $\text{In}(\mathscr{P}) := \bigcup_{i \in [n]} \text{In}_i(\mathscr{P})$,
  \item $\tx{IdealIn}_i(\mathscr{P}) := \tx{In}(P_i) \cap \tx{Out}(F)$,
  \item $\text{IdealIn}(\mathscr{P}) := \text{In}(F)$.
\end{itemize}

$\square$
\end{definition}

The ideal functionality can be asynchronous, which lets
us model things like channels with certain properties
inside of the functionality itself.
For convenience, we also allow multiple players
to use the same functions from the ideal functionality.
We explicitly define a leakage set, which will be 
more important later.
For now, we can think of it as part of the ideal functionality
that adversaries attacking the protocol will be able to interact with
directly.
The functions that the protocol can depend on are either
provided by other protocols, or other functionalities,
which is why we defined $\tx{In}$ and $\tx{IdealIn}$ that way.

The condition that the protocol dependencies be distinct
will make more sense later, when we define protocol composition,
but for now, the basic idea is that if one player uses
the functions provided by a player in a sub-protocol,
then that means that this players must completely take over
the role of the player in the sub-protocol,
and we want this relationship to be clear.

We can also define a notion of \emph{efficient} protocols.

\begin{definition}[Efficient Protocol]
  A protocol $\mathscr{P}$ is said to be \emph{efficient},
  if every player is an efficient system, and its ideal functionality
  is an efficient package.

  $\square$
\end{definition}

From now on, we only consider efficient protocols, unless otherwise
specified.

Similar to how we often talk about games, rather than just packages,
we'll often want to talk about protocols without any dependencies.

\begin{definition}[Closed Protocol]
  We say that a protocol $\mathscr{P}$ is \emph{closed} if
  $\tx{In}(\mathscr{P}) = \emptyset$ and $\tx{IdealIn}(\mathscr{P}) = \emptyset$.

  $\square$
\end{definition}

When we eventually get to defining notions of equality and simulation
for protocols, these will be targeting \emph{closed} protocols,
whose semantics are well defined, since no dependencies are left unfulfilled.

We can, however, define a very strong notion of equality right now.

\begin{definition}[Literal Equality]
Given two protocols $\mathscr{P}$ and $\mathscr{Q}$, we say that
they are \emph{literally equal}, written as $\mathscr{P} \equiv \mathscr{Q}$
when:
\begin{itemize}
\item $\mathscr{P}.n = \mathscr{Q}.n$
\item There exists a permutation $\pi : [n] \leftrightarrow [n]$ such that
$
{\forall i \in [n].\enspace \mathscr{P}.P_i \equiv \mathscr{Q}.P_{\pi(i)}}
$
\item $\mathscr{P}.F = \mathscr{Q}.F$
\item $\mathscr{P}.\tx{Leakage} = \mathscr{Q}.\tx{Leakage}$
\end{itemize}

$\square$
\end{definition}

So, the functionalities need to be the same,
and the players need to be \emph{literally} equal,
up to potential reordering.
We use literal equality because we're most likely
comparing systems with plenty of open channels,
and we want each player to behave the same regardless of what
the rest of the protocol is doing.

Like with literal equality for packages and systems, the main purpose
of this notion is to talk about the fundamental properties
of the composition operations.

Now, we get to our first notion of composition.
Protocols can depend on other protocols, but also other functionalities.
One natural kind of composition is to fill this demand,
by composing a protocol with another functionality.

\begin{definition}[Vertical Composition]
Given a protocol $\mathscr{P}$ and a package $G$, satisfying
$\text{IdealIn}(\mathscr{P}) \subseteq \text{Out}(G)$,
we can define the protocol $\mathscr{P} \circ G$.

$\mathscr{P} \circ G$ has the same players and leakage as $\mathscr{P}$,
but its ideal functionality $F$ becomes $F \circ G$.

$\square$
\end{definition}

This is more useful than it might seem at first.
We can use this kind of composition to separate out components
of the ideal functionality, which can then allow us to appeal
to theorems we've already proved about games to argue
about protocols.
This kind of composition can be seen as providing a
sort of ``bridge'' between the world of games and the world of protocols.

This composition is also well behaved, satisfying associativity.

\begin{claim}[Vertical Composition is Associative]
For any protocol $\mathscr{P}$, and packages $G, H$, such that their composition
is well defined, we have
$$
\mathscr{P} \circ (G \circ H) = (\mathscr{P} \circ G) \circ H
$$

\txbf{Proof:} This follows from the definition of vertical composition
and the associativity of $\circ$ for packages.

$\blacksquare$
\end{claim}

The next kind of composition we look at allows a protocol
to use another as a kind of sub-protocol.
The idea is that each player in one protocol plays the role
of one or several players in the sub-protocol.
The definition is somewhat involved, so we provide some more motivation
later.

\begin{definition}[Horizontal Composition]
Given two protocols $\mathscr{P}, \mathscr{Q}$,
we can define the protocol $\mathscr{P} \lhd \mathscr{Q}$,
provided a few requirements hold.

First, we need: $\text{In}(\mathscr{P}) \subseteq \text{Out}(\mathscr{Q})$.
We also require that the functions exposed by a player in $\mathscr{Q}$
are used by \emph{exactly} one player in $\mathscr{P}$.
We express this as:
\[
  \forall i \in [\mathscr{Q}.n].\ \exists! j \in [\mathscr{P}.n].\quad \text{In}_j \cap \text{Out}_i \neq \emptyset
\]

Second, we require that the players share no channels between the two
protocols.
In other words $\text{Chan}(\mathscr{P}.P_i) \cap \text{Chan}(\mathscr{Q}.P_j) = \emptyset$, for all $P_i, P_j$.

Third, we require that the ideal functionalities of one protocol aren't used in the other.
$$
\begin{aligned}
&\tx{Out}(\mathscr{P}.F) \cap \tx{In}(\mathscr{Q}) = \emptyset\cr
&\tx{Out}(\mathscr{Q}.F) \cap \tx{In}(\mathscr{P}) = \emptyset
\end{aligned}
$$

Finally, we require that the ideal functionalities do not overlap, 
  in the sense that $\text{Out}(\mathscr{P}.F) \cap \text{Out}(\mathscr{Q}.F) = \emptyset$

Our first condition has an interesting consequence: every player $\mathscr{Q}.P_j$
has its functions used by exactly one player $\mathscr{P}.P_i$.
In that case, we say that $\mathscr{P}.P_i$ \emph{uses} $\mathscr{Q}.P_j$.

With this in hand, we can define $\mathscr{P} \lhd \mathscr{Q}$.

The players will consist of:
$$
  \mathscr{P}.P_i \circ
  \begin{pmatrix}
    {\displaystyle \bigast_{\mathscr{Q}.P_j \text{ used by } \mathscr{P}.P_i } \mathscr{Q}.P_j} \cr
    \otimes\cr
    1(\tx{IdealIn}_i)
  \end{pmatrix}
$$
And, because of our assumption, each player in $\mathscr{Q}$ appears
somewhere in this equation.

The ideal functionality is $\mathscr{P}.F \otimes \mathscr{Q}.F$,
and the leakage is $\mathscr{P}.\tx{Leakage} \cup \mathscr{Q}.\tx{Leakage}$.

We can also easily show that this definition is well defined, satisfying
the required properties of an protocol.
Because of the definition of the players, we see that:
$$
  \bigcup_{i \in [(\mathscr{P} \lhd \mathscr{Q}).n]} \tx{OutChan}((\mathscr{P} \lhd \mathscr{Q}).{P_i})
  = \left(\bigcup_{i \in [\mathscr{P}.n]} \tx{OutChan}(\mathscr{P}.P_i)\right) \cup
  \left(\bigcup_{i \in [\mathscr{Q}.n]} \tx{OutChan}(\mathscr{Q}.P_i)\right)
$$
  since $\text{OutChan}(A \circ B) = \text{OutChan}(A \otimes B) = \text{OutChan}(A, B)$.
A similar reasoning applies to $\text{InChan}$, allowing us to conclude that:
$$
  \bigcup_{i \in [(\mathscr{P} \lhd \mathscr{Q}).n]} \tx{OutChan}((\mathscr{P} \lhd \mathscr{Q}).{P_i}) =
  \bigcup_{i \in [(\mathscr{P} \lhd \mathscr{Q}).n]} \tx{InChan}((\mathscr{P} \lhd \mathscr{Q}).{P_i})
$$
as required.

By definition, the dependencies $\text{In}$ of each player in $\mathscr{P} \lhd \mathscr{Q}$
are the union of several players in $\mathscr{Q}$, and
the ideal dependencies of players in $\mathscr{P}$,
both of these are required to be disjoint, so the disjointedness property
continues to hold.

Finally, since each player is of the form $\mathscr{P}.P_i \circ \ldots$,
the condition on $\text{Out}_i$ is also satisfied in $\mathscr{P} \lhd \mathscr{Q}$,
since $\mathscr{P}$ does.

$\square$

\end{definition}

The second part of the definition is in fact a proof that the definition
produces a valid protocol.
The conditions guarantee that the two protocols are isolated
from each other, beyond the fact that the players in $\mathscr{P}$
are able to control the players in $\mathscr{Q}$ via the functions they provide.
The protocols don't share any channels, or an ideal functionality.
The end result is a protocol in which each player
is ``emulating'' the behavior of the players in the sub-protocol,
and where even though the channels are now shared, it's clear
whether a message is intended for the main protocol,
or for a specific player in the sub-protocol.

Horizontal composition is also well behaved.
For example, it satisfies associativity.

\begin{lemma}
Horizontal composition is associative, i.e.
${\mathscr{P} \lhd (\mathscr{Q} \lhd \mathscr{R}) \equiv (\mathscr{P} \lhd \mathscr{Q}) \lhd \mathscr{R}}$
for all protocols $\mathscr{P}, \mathscr{Q}, \mathscr{R}$ where this expression is well defined.

$\txbf{Proof:}$
For the ideal functionalities, it's clear that by the associativity
of $\otimes$ for systems, the resulting functionality is the same
in both cases.

The trickier part of the proof is showing that the resulting players
are identical.

It's convenient to define a relation for the players in $\mathscr{R}$
that get used in $\mathscr{P}$ via the players in $\mathscr{Q}$.
To that end, we say that $\mathscr{P}.P_i$ \emph{uses} $\mathscr{R}.P_j$
if there exists $\mathscr{Q}.P_k$ such that $\mathscr{P}.P_i$ uses
$\mathscr{Q}.P_k$, and $\mathscr{Q}.P_k$ uses $\mathscr{R}.P_j$.

The players of $\mathscr{P} \lhd (\mathscr{Q} \lhd \mathscr{R})$ are of the form:
$$
  \mathscr{P}.P_i \circ
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{Q}.P_j \text{ used by } \mathscr{P}.P_i } 
  \mathscr{Q}.P_j \circ
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{R}.P_k \text{ used by } \mathscr{Q}.P_j } \mathscr{R}.P_k\cr
  \otimes\cr
  1(\mathscr{Q}.\tx{IdealIn}_j)
  \end{pmatrix}\cr
  \otimes\cr
  1(\mathscr{P}.\tx{IdealIn}_i)
  \end{pmatrix}
$$
While those in $(\mathscr{P} \lhd \mathscr{Q}) \mathscr{R}$ are of the form:
$$
  \left( \mathscr{P}.P_i \circ
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{Q}.P_j \text{ used by } \mathscr{P}.P_i } 
  \mathscr{Q}.P_j\cr
  \otimes\cr
  1(\mathscr{P}.\tx{IdealIn}_i)
  \end{pmatrix}
  \right)
  \circ
  \begin{pmatrix}
    \displaystyle \bigast_{\mathscr{R}.P_k \text{ used by } \mathscr{P}.P_i } \mathscr{R}.P_k\cr
  \otimes\cr
  1(\mathscr{Q}.\tx{IdealIn}_j)
  \end{pmatrix}
$$
Now, we can apply the associativity of $\circ$ for systems, and also
group the $\mathscr{R}.P_k$ players based on which $\mathscr{Q}.P_j$ uses them:
$$
  \mathscr{P}.P_i \circ
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{Q}.P_j \text{ used by } \mathscr{P}.P_i } 
  \mathscr{Q}.P_j\cr
  \otimes\cr
  1(\mathscr{P}.\tx{IdealIn}_i)
  \end{pmatrix}
  \circ
  \left(
    \displaystyle \bigast_{\mathscr{Q}.P_j}
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{R}.P_k \text{ used by } \mathscr{Q}.P_j } \mathscr{R}.P_k
  \cr
  \otimes\cr
  1(\mathscr{Q}.\tx{IdealIn}_j)
  \end{pmatrix}
  \right)
$$
Now, the conditions are satisfied for applying the interchange lemma (Lemma~\ref{thm:interchange_system}),
giving us:
$$
  \mathscr{P}.P_i \circ
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{Q}.P_j \text{ used by } \mathscr{P}.P_i } 
  \mathscr{Q}.P_j \circ
  \begin{pmatrix}
  \displaystyle \bigast_{\mathscr{R}.P_k \text{ used by } \mathscr{Q}.P_j } \mathscr{R}.P_k\cr
  \otimes\cr
  1(\mathscr{Q}.\tx{IdealIn}_j)
  \end{pmatrix}\cr
  \otimes\cr
  1(\mathscr{P}.\tx{IdealIn}_i)
  \end{pmatrix}
$$
Which is non other than the players in $\mathscr{P} \lhd (\mathscr{Q} \lhd \mathscr{R})$.

$\blacksquare$
\end{lemma}

Next, we define another fundamental way to compose protocols:
concurrent composition.
The idea here is that this allows two protocols to run side
by side, without any interaction.
The resulting protocol will have two independent sets of players,
each running their own protocol together.

\begin{definition}[Concurrent Composition]
Given two protocols $\mathscr{P}, \mathscr{Q}$,
we can define their concurrent composition---or tensor product---
$\mathscr{P} \otimes \mathscr{Q}$, provided a few requirements hold.
We require that:
\begin{enumerate}
\item $\tx{In}(\mathscr{P}) \cap \tx{In}(\mathscr{Q}) = \emptyset$.
\item $\tx{Out}(\mathscr{P}) \cap \tx{Out}(\mathscr{Q}) = \emptyset$.
\item $\tx{Out}(\mathscr{P}.F) \cap \tx{Out}(\mathscr{Q}.F) = \emptyset$ \emph{or} $\mathscr{P}.F = \mathscr{Q}.F$.
\item $\tx{Leakage}(\mathscr{P}) \cap \tx{In}(\mathscr{Q}) = \emptyset = \tx{Leakage}(\mathscr{Q}) \cap \tx{In}(\mathscr{P})$
\end{enumerate}

The players of $\mathscr{P} \otimes \mathscr{Q}$ consist of all the players
in $\mathscr{P}$ and $\mathscr{Q}$.
The ideal functionality is $\mathscr{P}.F \otimes \mathscr{Q}.F$, 
unless $\mathscr{P}.F = \mathscr{Q}.F$, in which case the ideal functionality
is simply $\mathscr{P}.F$.
In either case, the leakage is $\mathscr{P}.\tx{Leakage} \cup \mathscr{Q}.\tx{Leakage}$.
This use of $\otimes$ is well defined by assumption.

The resulting protocol is also clearly well defined.

The jointly closed property holds because we've simply taken the union
of both player sets.

Since $\tx{In}(\mathscr{P}) \cap \tx{In}(\mathscr{Q}) = \emptyset$,
it also holds that for every $P_i, P_j$ in $\mathscr{P} \otimes \mathscr{Q}$,
we have $\tx{In}(P_i) \cap \tx{In}(P_j) = \emptyset$,
since each player comes from either $\mathscr{P}$ or $\mathscr{Q}$.
      
Finally, $\tx{Out}(\mathscr{P}) \cap \tx{Out}(\mathscr{Q}) = \emptyset$,
we have that $\tx{Out}(P_i) \cap \tx{Out}(P_j) = \emptyset$,
by the same reasoning.
    
$\square$
\end{definition}

One detail which might seem odd at first is that we allow
for $\mathscr{P}.F = \mathscr{Q}.F$, handling that case a bit separately.
This is useful because it allows accommodating a common situation
where both protocols have a functionality of the form $1(S)$,
for some set, and we want to allow them to be composed,
to then later write $(\mathscr{P} \otimes \mathscr{Q}) \circ G$,
for some package $G$.
Having a shared functionality between concurrent protocols
is something we do want to be possible, so handling
this edge case is necessary.

This notion of composition is also well behaved, as we now prove.

\begin{lemma}
Concurrent composition is associative and commutative,
i.e. $\mathscr{P} \otimes (\mathscr{Q} \otimes \mathscr{R}) \equiv (\mathscr{P} \otimes \mathscr{Q}) \otimes \mathscr{R}$,
and $\mathscr{P} \otimes \mathscr{Q} \equiv \mathscr{Q} \otimes \mathscr{P}$ for
all protocols $\mathscr{P}, \mathscr{Q}, \mathscr{R}$ where these expressions
are well defined.

\txbf{Proof:}

By the definition of $\equiv$, all that matter is the \emph{set} of players,
and not their order.
Because $\cup$ is associative, and so is $\otimes$ for systems,
we conclude that concurrent composition is associative as well,
since the resulting set of players and ideal functionality are the same
in both cases.

Similarly, since $\cup$ and $\otimes$ (for systems) are commutative,
we conclude that concurrently composition is commutative.

$\blacksquare$
\end{lemma}

The utility of concurrent composition and horizontal composition
is enhanced even more when combined together.
As an example, consider the common situation where a
protocol involves several tasks executed in sequence.
One way of writing this would be:
$$
\mathscr{O} \lhd
\begin{pmatrix}
  \mathscr{Q}_1\cr
  \otimes\cr
  \mathscr{Q}_2
\end{pmatrix}
$$
where $\mathscr{Q}_i$ are sub-protocols for each task,
and $\mathscr{O}$ is an orchestration protocol running the tasks in sequence.
This decomposition allows a more fine-grained analysis of the protocol's
security.

\subsection{Corruption}

The goal of this section is to formally define the semantics
of protocol.
We've defined a protocol so far in terms of isolated players,
with strong hints as to how the players will interact,
but we haven't actually defined how to compose these players
together to form an actual system.
The idea is that if we know which players are corrupted,
and in what way, we can then compile the protocol
into a system that an adversary can interact with.
They will be able to use the corrupted and honest
players to drive the execution of the protocol,
in an attempt to distinguish it from other protocols.

An important consideration as we define various kinds of corruption
is that if two players are equal, then the way the corrupted
players behave should also be equal.
We've encountered this kind of equality preservation before,
and it's a property we'll keep an eye out for in this subsection as well.

The first kind of corruption we consider is that of a party which
isn't actually corrupted.

\begin{definition}[``Honest'' Corruption]
Given a system $P$,
we define the ``honest'' corruption of $P$
$$
\tx{Corrupt}_H(P) := P
$$

This is clearly equality preserving, by tautology.

$\square$
\end{definition}

This is nonetheless a useful definition to have, since we don't
have to treat the honest players as being completely separate
from the dishonest players, but rather just corrupted in a different way.

Next, we look at semi-honest corruption.
The intuition here is that such a corrupted party will still
follow the protocol's execution, but the adversary 
gains additional visibility into the execution of that player.

\begin{definition}[Semi-Honest Corruption]
Given a system $P$, we can define
the semi-honest corruption $\tx{Corrupt}_{\tx{SH}}(P)$.

This is a transformation of
of $P$, providing access to its ``view''.
More formally, $\tx{Corrupt}_{\tx{SH}}(P)$ is a system which works the same
as $P$, but with an additional public variable $\tx{log}$,
which contains several sub logs:
\begin{enumerate}
  \item $\tx{log}.{A_i}$ for each sending channel $A_i$,
  \item $\tx{log}.{B_i}$ for each receiving channel $B_i$,
  \item $\tx{log}.F$ for each input function $F$.
  \item $\tx{log}.G$ for each output function $G$.
\end{enumerate}
Each of these sub logs is initialized with ${\tx{log}.\bullet \gets \tx{FifoQueue.New()}}$.
Additionally, $\tx{Corrupt}_{\tx{SH}}(P)$ modifies $P$ by pushing events to these
logs at different points in time.
These events are:
\begin{itemize}
\item $(\texttt{call}, (x_1, \ldots, x_n))$ to $\tx{log}.F$ when a function call $F(x_1, \ldots, x_n)$ happens.
\item $(\texttt{ret}, y)$ to $\tx{log}.F$ when the function $F$ returns a value $y$.
\item $(\texttt{input}, (x_1, \ldots, x_n))$ to $\tx{log}.G$ when the function $G$ is called with $(x_i, \ldots)$ as input.
\item $m$ to $\tx{log}.A$ when a value $m$ is sent on channel $A$.
\item $m$ to $\tx{log}.B$ when a value $m$ is received on channel $B$.
\end{itemize}

This transformation is also equality respecting.
First, note that if $P \equiv P'$ as systems, then
then $\tx{NoChan}(P) = \tx{NoChan}(P')$, and so their logs will be the same.

$\square$
\end{definition}
The use of different logs is very useful, since it makes manipulating
the log easier, avoiding the need to parse the log to separate
out events by function.

One important detail is that the log also contains entries
for when the player itself is activated through one of its input functions.
This will be useful when reasoning about how protocol composition behaves,
because the input events in one players log can become the output function
events in the log of a player calling that sub-protocol.

Note that, unlike other definitions of semi-honest corruption,
we do not provide access to the randomness sampled by a player,
at least not directly.
The reason for doing this is ultimately that defining corruption
in that way is very difficult to do while preserving equality.
There are many equivalent ways to write a given player
which result in different sampling patterns.
In practice, we don't think this is a strong limitation,
because we can also see all of the output functions and
channels used by the player, so significant randomness can still
be observed.

Now, onto malicious corruption:

\begin{definition}[Malicious Corruption]
Given a system $P$ with:
$$
\begin{aligned}
  &\tx{In}(P) = \{F_1, \ldots, F_n\}\cr
  &\tx{OutChan}(P) = \{A_1, \ldots, A_m\}\cr
  &\tx{InChan}(P) = \{B_1, \ldots, B_l\}\cr
\end{aligned}
$$
we define the malicious corruption $\tx{Corrupt}_M(P)$ as the following game:
\package{$\tx{Corrupt}_M(P)$}{
&\underline{\tx{Call}_{F_i}((x_1, \ldots, x_n))\tx{:}}\cr
\pind{1} \preturn{F_i(x_1, \ldots, x_n)}\cr
\cr
&\underline{\tx{Send}_{A_i}(m)\tx{:}}\cr
\pind{1} \psend{m}{A_i}\cr
\cr
&\underline{\tx{Test}_{B_i}()\tx{:}}\cr
\pind{1} \preturn{\txbf{test } B_i}\cr
\cr
&\underline{\tx{Recv}_{B_i}()\tx{:}}\cr
\pind{1} \preturn{\precv{m}{B_i}}\cr
}

In other words, malicious corruption provides access to the functions
and channels used by $P$, but no more than that.

This is also equality preserving, since $\tx{Corrupt}_M(P)$ depends
only on the channels used by $P$ and the functions called by $P$,
all of which are the same for any $P' \equiv P$.

$\square$
\end{definition}

The intuitive idea behind malicious corruption is that this party
can deviate arbitrarily from the protocol.
The adversary corrupting this party can call any function this
party is allowed to call, and use any channel this party uses.

An interesting property of the kinds of corruption is that
each form of corruption is stronger than the other.
A semi-honest party provides more information than an honest
party, and a malicious party doesn't even need to follow
the protocol anymore.
We can capture this hierarchy formally.

\begin{lemma}[Simulating Corruptions]
  \label{thm:simulatingcorruption}
  We can simulate corruptions using strong forms of corruption.
  In particular, there exists systems $S_{\tx{SH}}$ and $S_{\tx{H}}$ such that
  for all systems $P$, we have:
  \[
    \begin{aligned}
      &\tx{Corrupt}_{\tx{SH}}(P) = S_{\tx{SH}} \circ \tx{Corrupt}_M(P)\cr
      &\tx{Corrupt}_{\tx{H}}(P) = S_{\tx{H}} \circ \tx{Corrupt}_{\tx{SH}}(P)
    \end{aligned}
  \]

\txbf{Proof:}
For the simulation of honest corruption, we can simply ignore
  the additional log variable, and set $S_{\tx{H}} := 1(\tx{Out}(P))$.

For semi-honest corruption, $S_{\tx{SH}}$ is formed by first transforming
$\tx{Corrupt}_{\tx{SH}}(P)$, replacing:
\begin{itemize}
  \item every function call with $\tx{Call}_{F_i}(\ldots)$,
  \item every sending of a message $m$ on $A$ with $\tx{Send}_A(m)$,
  \item every length test of $B$ with $\tx{Test}_B()$,
  \item every reception of a message on $B$ with $\tx{Recv}_B()$.
\end{itemize}

The result is clearly a perfect emulation of semi-honest corruption
using malicious corruption.

$\blacksquare$
\end{lemma}

We'll be using this lemma later, where it will help us show
that in some situations, it suffices to consider only malicious
corruption, which can simplify many proofs.

Next, we'll be defining what it means to actually execute
a protocol with some players being corrupted.
The first notion we'll need to develop is that of a \emph{corruption model},
which is just a way of specifying which players in a protocol are corrupted,
and how.

Before that, we need a little syntax to talk about corruptions in general,
and so define the shorthand $\text{Corrupt}_\kappa(P)$,
for $\kappa \in \{\tx{H}, \tx{SH}, \tx{M}\}$.

\begin{definition}[Corruption Models]
Given a protocol $\mathscr{P}$ with players $P_1, \ldots, P_n$, a \emph{corruption model} $C$
is a function $C : [\mathscr{P}.n] \to \{\tx{H}, \tx{SH}, \tx{M}\}$.
This provides a corruption $C_i$ associated with each player $P_i$.
We can then define $\text{Corrupt}_C(P_i) := \text{Corrupt}_{C_i}(P_i)$.

Corruption models have a natural partial order associated with them. 
We have:
$$
\tx{H} < \tx{SH} < \tx{M}
$$
  and then we say that $C \geq C'$ if $\forall i \in [n]. \quad C_i \geq C'_i$.

A \emph{class of corruptions} $\mathscr{C}$ is simply a set of corruption models.

$\square$
\end{definition}

Some common classes are:
\begin{itemize}
  \item The class of malicious corruptions, where all but one player is malicious.
  \item The class of malicious corruptions, where all but one player is semi-honest.
\end{itemize}

The notion of class is very useful, and is what we usually end up proving
things about.
For example, we prove that two protocols are the same under a given
class of corruptions.
That proof will involve looking at each model inside the class,
as we'll see later.

Now, let's define what the semantics of a protocol are under
a given corruption model.
These semantics should define how an adversary can run and interact
with a protocol, having corrupted some of the parties.

\begin{definition}[Instantiation]
  Given a protocol $\mathscr{P}$ with $\tx{In}(\mathscr{P}) = \emptyset$, and a corruption model $C$, we can
  define an \emph{instantiation} $\tx{Inst}_C(\mathscr{P})$, which
  is a system defining the semantics of the protocol.

  First, we need to define a transformation of systems to use
  a \emph{router} $\mathcal{R}$, which will be a special system
  allowing an adversary to control the order of delivery of messages.

  Let $\{A_1, \ldots, A_n\} = \tx{Chan}(P_1, \ldots, P_n)$.
  We then define $\mathcal{R}$ as the system:
\package{$\mathcal{R}$}{
&\underline{\tx{Deliver}_{A_i}()\tx{:}}\cr
\pind{1} \precv{m}{\langle A_i, \mathcal{R} \rangle}\cr
\pind{1} \psend{m}{\langle \mathcal{R}, A_i \rangle}\cr
}

  Next, we define a transformation $\tx{Routed}(S)$ of a system,
  which makes communication pass via the router:
  \begin{itemize}
    \item Whenever $S$ sends $m$ via $A$, $\tx{Routed}(S)$ sends $m$ via $\langle A , \mathcal{R} \rangle$.
    \item Whenever $S$ receives $m$ via $B$, $\tx{Routed}(S)$ receives $m$ via $\langle \mathcal{R}, B \rangle$.
  \end{itemize}

With this in hand, we define:
$$
\tx{Inst}_C(\mathscr{P}) :=
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [n]} \tx{Routed}(\tx{Corrupt}_C(P_i))\cr
    *\cr
    \mathcal{R}\cr
    \otimes\cr
    1(\tx{Leakage})
  \end{pmatrix}
  \circ F
$$


$\square$
\end{definition}

The basic idea is that the adversary can call the functions
provided by any player, along with the leakage exposed
by the ideal functionality.
This provides a very asynchronous notion of execution,
where the adversary is able to run different parts of the protocol
at will.
There isn't even a clear ``entry point''.
Each player might have multiple functions that are provided,
and the adversary is able to start with whichever one they want.

The use of the router allows the adversary to control the flow
of messages in the protocol, deciding when a message should be delivered.
In this model, the adversary can't reorder messages, but one can
model protocols in which this happens either via a functionality,
or by having each message delivered on a separate channel.

Our next steps will be exploring how instantiation behaves
for composed protocols, so that we can extract some insights
that we can use when proving properties of the various
notions of equality we define later.

We start this exploration by looking at a few convenient properties
of our routing transformation.

\begin{lemma}[Properties of $\tx{Routed}$]
  \label{thm:routed}
  For any systems $A, B$, we have:
$$
\begin{aligned}
  &\tx{Routed}(A \circ B) = \tx{Routed}(A) \circ \tx{Routed}(B)\cr
  &\tx{Routed}(A * B) = \tx{Routed}(A) * \tx{Routed}(B)\cr
  &\tx{Routed}(A \otimes B) = \tx{Routed}(A) \otimes \tx{Routed}(B)\cr
\end{aligned}
$$
(provided these expressions are well defined)

\txbf{Proof:} The $\tx{Routed}$ transformation simply
renames each sending and receiving channel in a system.
In all the cases above, even $A * B$, all of the channels present
in $A$ and $B$ are present in the composition, and so all
of these equations hold.

$\blacksquare$
\end{lemma}

This will be very useful for our proofs soon enough.

Eventually, we'll want to prove things like ``if $\mathscr{Q}$
behaves the same as $\mathscr{Q}'$, then $\mathscr{P} \lhd \mathscr{Q}$
behaves the same as $\mathscr{P} \lhd \mathscr{Q}'$''.
Whenever we talk about behavior, we need to define a corruption model,
so that we can actually instantiate the protocol.
There is a slight issue here, in that a corruption
model is specific to one protocol.
A corruption model might say how $\mathscr{Q}$'s players should be
corrupted, but how does this then apply to
$\mathscr{P} \lhd \mathscr{Q}$?
Thankfully, for the ways of composing protocols we've defined,
there are natural notions of corruption which make sense in such
a situation.
If $\mathscr{Q}$ is corrupted in a certain way, then that
implies that certain corruptions need to happen
to have $\mathscr{P} \lhd \mathscr{Q}$ make sense as well.

We define this more formally, through the notion of \emph{compatible}
corruptions.

\begin{definition}[Compatible Corruptions]
  \label{def:compatc}
  Given protocols $\mathscr{P}, \mathscr{Q}$, and a corruption model
  $C$ for $\mathscr{Q}$, we can define a notion of a \emph{compatible}
  corruption model $C'$ for $\mathscr{P} \otimes \mathscr{Q}$ or $\mathscr{P} \lhd \mathscr{Q}$,
  provided these expressions are well defined.

  A corruption model $C'$ for $\mathscr{P} \otimes \mathscr{Q}$.
  is compatible with $C$ when every corruption of a player
  in $\mathscr{Q}$ is $\geq$ that of the corresponding corruption in $C$.

  We say that a corruption model $C'$ for $\mathscr{P} \lhd \mathscr{Q}$ is compatible with
a corruption model $C$ for $\mathscr{Q}$ if for every
$\mathscr{Q}.P_j$ used by $\mathscr{P}.P_i$, the corruption
level of $\mathscr{Q}.P_j$ in $\mathscr{C}'$ is $\geq$ the corruption level of $\mathscr{P}.P_i$
in $\mathscr{C}$.

  Furthermore, we say that $C'$ is \emph{strictly} compatible
  with $C$ if the above property holds with $=$, and not just $\geq$.

  This extends to corruption \emph{classes} as well.
  A corruption class $\mathscr{C}'$ is (strictly) compatible with a class $\mathscr{C}$,
  if every $C' \in \mathscr{C}'$ is (strictly) compatible with some $C \in \mathscr{C}$.

  $\square$
\end{definition}

For tensoring, compatibility is quite simple, we just need the players
that belong to $\mathscr{P}$'s ``side'' of the protocol
to be corrupted in the same way, or worse.
For composition, the idea is that for a player in a sub-protocol
to be corrupted, then the player using it in the main protocol
needs to be at least as corrupt.
For technical reasons, we'll also be needing
this notion of \emph{strict} compatibility.
This avoids situations where a player $P$ uses two players $Q_1$,
and $Q_2$, but only $Q_2$ is malicious.
In that case, we'd require $P$ to be malicious for compatibility,
but if $Q_1$ is honest, the corruption of $P$
might be too strong now for certain properties to hold.
If this doesn't quite make sense now, hopefully it will
be clearer when reading the proofs that make use of this strict
property.

As a first use of this notion of compatibility, we make
a fundamental observation about instantiating the concurrent composition
of protocols.
This is elevated to a theorem, because this breakdown observation
will be used as the crux of all of our equality related theorems about concurrent
composition.

\begin{theorem}[Concurrent Breakdown]
  \label{thm:concurrent_breakdown}
  Given protocols $\mathscr{P}, \mathscr{Q}$, and a corruption model $C$
  for $\mathscr{Q}$, then for any corruption model $C'$ for $\mathscr{P} \otimes \mathscr{Q}$ compatible with $C$, we have:
  \[
    \tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}) = \tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q})
  \]
\txbf{Proof:} If we unroll $\text{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q})$, we get:
$$
\begin{pmatrix}
\mathcal{R}\cr
*\cr
\left(\bigast_{i \in [\mathscr{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathscr{P}.P_i))\right)\cr
*\cr
\left(\bigast_{i \in [\mathscr{Q}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathscr{Q}.P_i))\right)\cr
\otimes\cr
1(\mathscr{P}.\tx{Leakage}, \mathscr{Q}.\tx{Leakage})
\end{pmatrix}
\circ
\begin{pmatrix}
\mathscr{P}.F\cr
\otimes\cr
\mathscr{Q}.F\cr
\end{pmatrix}
$$

We can apply a few observations here:
\begin{enumerate}
  \item Since $\mathscr{C}'$ is compatible with $\mathscr{C}$, then $\mathscr{Q}.P_i$ follows a corruption from $\mathscr{C}$.
  \item $\mathcal{R}$ can be written as $\mathcal{R}_\mathscr{P} \otimes \mathcal{R}_\mathscr{Q}$,
  with one system using channels in $\mathscr{P}$, and the other using channels in $\mathscr{Q}$.
  \item Since protocols are closed, we can use $\otimes$ between the players in $\mathscr{P}$ and $\mathscr{Q}$,
  since they never send messages to each other.
\end{enumerate}
This results in the following:
$$
\begin{pmatrix}
  \mathcal{R}_{\mathscr{P}} * \left(\bigast_{i \in [\mathscr{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathscr{P}.P_i))\right) \otimes 1(\mathscr{P}.\tx{Leakage})\cr
\otimes\cr
  \mathcal{R}_{\mathscr{Q}} * \left(\bigast_{i \in [\mathscr{Q}.n]} \tx{Routed}(\tx{Corrupt}_{C}(\mathscr{Q}.P_i))\right) \otimes 1(\mathscr{Q}.\tx{Leakage})
\end{pmatrix}
\circ
\begin{pmatrix}
\mathscr{P}.F\cr
\otimes\cr
\mathscr{Q}.F\cr
\end{pmatrix}
$$
From here, we apply Lemma~\ref{thm:interchange_system} (interchange), to get:
$$
\begin{matrix}
\tx{Inst}_{C'}(\mathscr{P})\cr
\otimes\cr
\tx{Inst}_{C}(\mathscr{Q})\cr
\end{matrix}
$$

$\blacksquare$

\end{theorem}

This is an extremely useful theorem, since it breaks down
the instantiation of the tensor product into another tensor product
of systems.
This observation is the cornerstone of proving the properties
that concurrent composition satisfies with respect to equality
and simulation.

Now, we tackle horizontal composition.
Unfortunately, the statement we have here is not quite as elegant
as that of concurrent composition.

\begin{theorem}[Horizontal Breakdown]
  \label{thm:horizontal_breakdown}
  Given protocols $\mathscr{P}, \mathscr{Q}$, and a corruption
  model $C$ for $\mathscr{Q}$, then for any compatible corruption
  model $C'$ for $\mathscr{P} \lhd \mathscr{Q}$, there exists
  systems $S_1, \ldots, S_{\mathscr{Q}.n}$ and a set $L_{\mathscr{Q}}$ such that:
  $$
  \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}) =
  1(O)\circ
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [\mathscr{P}.n]} \tx{Routed}(\tx{Corrupt}'_{C'}(\mathscr{P}.P_i))
    \cr
    *\cr
    \mathcal{R}_{\mathscr{P}}\cr
    \otimes\cr
    1(\tx{Leakage}, L_{\mathscr{Q}})
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \mathscr{P}.F\cr
    \otimes\cr
    1(\tx{Out}(\mathcal{R}_q))\cr
    \otimes\cr
    1(\mathscr{Q}.\tx{Leakage})\cr
    \otimes\cr
    \bigotimes_{i \in [\mathscr{Q}.n]} S_i\cr
  \end{pmatrix}
  \circ
  \begin{pmatrix}
  \tx{Inst}_C(\mathscr{Q})\cr
  \otimes\cr
  1(\tx{In}(\mathscr{P}.F))
  \end{pmatrix}
  $$
  where $O := \tx{Out}(\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}))$,
  $\mathcal{R}_{\mathscr{P}} \circ \mathcal{R}_{\mathscr{Q}} = \mathcal{R}$
  are a decomposition of the router $\mathcal{R}$ for $\mathscr{P} \lhd \mathscr{Q}$,
  and $\tx{Corrupt}'_{C'}(\ldots)$ is the same as $\tx{Corrupt}_{C'}$,
  except that malicious corruption contains no $\tx{Call}_{F_i}$ functions,
  for $F_i \notin \tx{Out}(\mathscr{P}.F)$

  Furthermore, if the models are \emph{strictly} compatible,
  then $S_j = 1(\tx{Out}(\tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}.P_i))))$.

\txbf{Proof:} We start by unrolling $\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q})$,
to get:
\[
\tx{Inst}_C(\mathscr{P} \lhd \mathscr{Q}) =
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [\mathscr{P}.n]} \tx{Routed}\left(\tx{Corrupt}_{C'}\left(\mathscr{P}.P_i \circ 
        
    \begin{pmatrix}
    \bigast_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i} \mathscr{Q}.P_j\cr
    \otimes\cr
    1(\tx{IdealIn}_i)
    \end{pmatrix}
    \right)\right)\cr
    *\cr
    \mathcal{R}\cr
    \otimes\cr
    1(\tx{Leakage})
  \end{pmatrix}
  \circ \begin{pmatrix}
    \mathscr{P}.F\cr
    \otimes \cr
    \mathscr{Q}.F
  \end{pmatrix}
\]
Our strategy will be to progressively build up an equivalent system
to this one, starting with $\tx{Corrupt}_C$, then $\tx{Routed}$, etc.

First, some observations about $\tx{Corrupt}_\kappa(P \circ (1(I) \otimes Q_1 * \cdots * Q_m))$,
where ${I \cap \tx{In}(Q_1, \ldots) = \emptyset}$.

In the case of malicious corruption, we have:
$$
\tx{Corrupt}_M(P \circ (1(I) \otimes Q_1 * \cdots)) =
1(O) \circ
\begin{pmatrix}
  \tx{Corrupt}'_M(P)\cr
  \otimes\cr
  1(\tx{Out}(\tx{Corrupt}_M(Q_1)), \ldots)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
  1(I)\cr
  \otimes\cr
  \tx{Corrupt}_M(Q_1)\cr
  *\cr
  \cdots\cr
\end{pmatrix}
$$
for $O = \tx{Out}(\tx{Corrupt}_M(P \circ (Q_1 * \cdots)))$.
This holds by definition, since corruption $P \circ (Q_1 * \cdots)$ precisely allows
sending messages on behalf of $P$ or any $Q_i$, as well as calling
the input functions to the $Q_i$ systems.
Since we can't call the functions that $P$ uses,
we use $\tx{Corrupt}'_{M}$, which modifies malicious corruption to only
contain $\tx{Send}_{A_i}$, $\tx{Test}_{B_i}$, $\tx{Recv}_{B_i}$,
and $\tx{Call}_{F_i}$ for $F_i \in I$.
In particular the $\tx{Call}_{\bullet}$ functions are omitted for the functions
provided by $Q_1, \ldots, Q_m$.
We can write this expression more concisely,
using $1(L^M)$ for $L^M = \tx{Out}(\tx{Corrupt}_M(Q_1)) \cup \cdots$.

Next, we look at semi-honest corruption.
Because the logs are divided into independent sub logs, we can write:
$$
\tx{Corrupt}_{\tx{SH}}(P \circ (1(I) \otimes Q_1 * \cdots)) =
1(O) \circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{SH}}(P)\cr
  \otimes\cr
  1(\{Q_1.\tx{log}, \ldots\})
\end{pmatrix}
\circ
\begin{pmatrix}
  1(I)\cr
  \otimes\cr
  \tx{Corrupt}_{\tx{SH}}(Q_1)\cr
  *\cr
  \cdots
\end{pmatrix}
$$
where $O = \tx{Out}(\tx{Corrupt}_{\tx{SH}}(P \circ (Q_1 * \cdots)))$

And for honest corruption, we have
$$
\tx{Corrupt}_{\tx{H}}(P \circ (1(I) \otimes Q_1 * \cdots)) = P \circ (1(I) \otimes Q_1 * \cdots)
$$

Now, the compatibility condition of $C'$ relative to $C$
does not guarantee that if $\mathscr{P}.P_i$ uses $\mathscr{Q}.P_j$,
then $\mathscr{Q}.P_j$ has the same level of corruption: 
it only guarantees a level of corruption at least as strong.
By Lemma~\ref{thm:simulatingcorruption}, we can simulate a weaker
form of corruption using a stronger form, via some simulator system $S$,
depending on the levels of corruption.

Using these simulators, we get, slightly different results based
on the level of corruption.

When $C'_i = \tx{M}$:
$$
\tx{Corrupt}_{C'}((\mathscr{P} \lhd \mathscr{Q}).P_i) =
1(O_i) \circ
\begin{pmatrix}
  \tx{Corrupt}'_{C'}(\mathscr{P}.P_i)\cr
  \otimes\cr
  1(L_i)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
\displaystyle \bigast_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i}
  \tx{Corrupt}_C(\mathscr{Q}.P_j)\cr
\otimes\cr
1(\tx{IdealIn}_i)
\end{pmatrix}
$$
with $O_i = \tx{Out}(\tx{Corrupt}_{C'}(\mathscr{P} \lhd \mathscr{Q}).P_i)$, $L_i= \bigcup_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i} \tx{Out}(\tx{Corrupt}_M(\mathscr{Q}.P_j))$.
No simulation is needed, since the compatibility of $C'$ with $C$
guarantees that all of the players used by $\mathscr{P}.P_i$
are maliciously corrupted.

When $C'_i = \tx{SH}$:
$$
\tx{Corrupt}_{C'}((\mathscr{P} \lhd \mathscr{Q}).P_i) =
1(O_i) \circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{C'}}(P)\cr
  \otimes\cr
  1(L_i)
\end{pmatrix}
\circ
\begin{pmatrix}
\displaystyle \bigast_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i}
  S_j \circ \tx{Corrupt}_C(\mathscr{Q}.P_j)\cr
  \otimes\cr
1(\tx{IdealIn}_i)
\end{pmatrix}
$$
with $O_i = \tx{Out}(\tx{Corrupt}_{C'}(\mathscr{P} \lhd \mathscr{Q}).P_i)$,
$L_i = \{\mathscr{Q}.P_j.\tx{log} \mid \mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i \}$,
and $S_j$ depending on the level of corruption for $\mathscr{Q}.P_j$ in $C$:
\begin{itemize}
  \item $S_j = S_{\tx{SH}}$ if $C_j = \tx{M}$
  \item $S_j = 1$ if $C_j = \tx{SH}$
\end{itemize}

When $C'_i = \tx{H}$:
$$
\tx{Corrupt}_{C'}((\mathscr{P} \lhd \mathscr{Q}).P_i) =
  \tx{Corrupt}_{\tx{C'}}(P)
\circ
\begin{pmatrix}
\displaystyle \bigast_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i}
  S_j \circ \tx{Corrupt}_C(\mathscr{Q}.P_j)\cr
\otimes\cr
1(\tx{IdealIn}_i)
\end{pmatrix}
$$
with $S_j$ depending on the level of corruption for $\mathscr{Q}.P_j$ in $C$:
\begin{itemize}
  \item $S_j = S_{\tx{H}} \circ S_{\tx{SH}}$ if $C_j = \tx{M}$
  \item $S_j = S_{\tx{H}}$ if $C_j = \tx{SH}$
  \item $S_j = 1$ if $C_j = \tx{H}$
\end{itemize}

We can unify these three cases, writing:
$$
\tx{Corrupt}'_{C'}((\mathscr{P} \lhd \mathscr{Q}).P_i) =
1(O_i) \circ
\begin{pmatrix}
  \tx{Corrupt}_{\tx{C'}}(P)\cr
  \otimes\cr
  1(L_i)
\end{pmatrix}
\circ
\begin{pmatrix}
\bigast_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i}
  S_j \circ \tx{Corrupt}_C(\mathscr{Q}.P_j)\cr
  \otimes\cr
1(\tx{IdealIn}_i)
\end{pmatrix}
$$
with $O_i$ and $L_i$ depending on the corruption level of $\mathscr{P}.P_i$,
and $S_j$ depending on the corruption levels of both $\mathscr{P}.P_i$
and $\mathscr{Q}.P_j$.

By the properties of $\tx{Routed}$ (Lemma~\ref{thm:routed}), we have:
$$
\begin{aligned}
&\tx{Routed}(\tx{Corrupt}'_{C'}((\mathscr{P} \lhd \mathscr{Q}).P_i)) =\cr
&1(O_i) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}'_{\tx{C'}}(P))\cr
  \otimes\cr
  1(L_i)
\end{pmatrix}
\circ
\begin{pmatrix}
\displaystyle\bigast_{\mathscr{Q}.P_j \tx{ used by } \mathscr{P}.P_i}
  S_j \circ \tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}.P_j))\cr
  \otimes\cr
1(\tx{IdealIn}_i)
\end{pmatrix}
\end{aligned}
$$

Next, we need to add the router $\mathcal{R}$.
We note that since $\mathscr{P}$ and $\mathscr{Q}$ have separate channels,
we can write $\mathcal{R} = \mathcal{R}_{\mathscr{P}} \circ \mathcal{R}_{\mathscr{Q}}$,
where the latter contains only the channels in $\mathscr{Q}$,
and the former contains the channels in $\mathscr{P}$,
and provides access to those in $\mathscr{Q}$ via its function dependencies.
Combing this with the interchange lemma, we get:
$$
\begin{aligned}
&\mathcal{R} * \bigast_{i \in [\mathscr{P}.n]}\tx{Routed}(\tx{Corrupt}'_{C'}((\mathscr{P} \lhd \mathscr{Q}).P_i)) * \mathcal{R} =\cr
&1(\tx{Out}(\mathcal{R}), O_1, \ldots, O_{\mathscr{P}.n}) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}_{\tx{C'}}(P))\cr
  *\cr
  \mathcal{R}_{\mathscr{P}}\cr
  \otimes\cr
  1(L_1, \ldots, L_{\mathscr{P}.n})
\end{pmatrix}
\circ
\begin{pmatrix}
\bigast_{j \in [\mathscr{Q}.n]}
  S_j \circ \tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}.P_j))
  \cr
  *\cr
  \mathcal{R}_{\mathscr{Q}}\cr
  \otimes\cr
  1(\tx{Out}(F))
\end{pmatrix}
\end{aligned}
$$

All that remains is to add the ideal functionalities, giving us,
after application of the interchange lemma:
$$
\begin{aligned}
  &\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}) =\cr
&1(O) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}'_{\tx{C'}}(P))\cr
  *\cr
  \mathcal{R}_{\mathscr{P}}\cr
  \otimes\cr
  1(\tx{Leakage}, L_{\mathscr{Q}})
\end{pmatrix}
\circ
\begin{pmatrix}
\bigast_{j \in [\mathscr{Q}.n]}
  S_j \circ \tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}.P_j))
  \cr
  *\cr
  \mathcal{R}_{\mathscr{Q}}\cr
  \otimes\cr
  1(\tx{Leakage}, \tx{Out}(F))
\end{pmatrix}
\circ
\begin{pmatrix}
  \mathscr{P}.F\cr
  \otimes\cr
  \mathscr{Q}.F
\end{pmatrix}
\end{aligned}
$$
with $O := \tx{Out}(\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}))$,
and $L_{\mathscr{Q}} := \bigcup_{i \in [\mathscr{P}.n]} L_i$.

Now, because $\mathscr{Q}$ does not use any of the functions
in $\mathscr{P}.F$, and because each simulator $S_j$
does not use any channels, we can rewrite this as:
$$
\small
1(O) \circ
\begin{pmatrix}
  \tx{Routed}(\tx{Corrupt}'_{\tx{C'}}(P))\cr
  *\cr
  \mathcal{R}_{\mathscr{P}}\cr
  \otimes\cr
  1(\tx{Leakage}, L_{\mathscr{Q}})
\end{pmatrix}
\circ
\begin{pmatrix}
  \mathscr{P}.F\cr
  \otimes\cr
  1(\tx{Out}(\mathcal{R}_{\mathscr{Q}}))\cr
  \otimes\cr
  1(\mathscr{Q}.\tx{Leakage})\cr
  \otimes\cr
  \bigotimes_{j \in [\mathscr{Q}.n]} S_j
\end{pmatrix}
\circ
\begin{pmatrix}
\begin{pmatrix}
\bigast_{j \in [\mathscr{Q}.n]}
  \tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}.P_j))
  \cr
  *\cr
  \mathcal{R}_{\mathscr{Q}}\cr
  \otimes\cr
  1(\mathscr{Q}.\tx{Leakage})
\end{pmatrix}
\circ
  \mathscr{Q}.F
  \cr
  \otimes\cr
  1(\tx{In}(\mathscr{P}.F))
\end{pmatrix}
$$

We can then notice that the right hand side of this equation
is simply $\tx{Inst}_C(\mathscr{Q})$,
concluding our proof.

$\blacksquare$

\end{theorem}

If you squint at this theorem, it's basically saying
that
$$
\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q})
= \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q})
$$
while also allowing the inputs to $\mathscr{P}.F$ to flow in.
This is the core observation we need for later.
If we look at the decomposition more closely,
the front is almost like
the $\tx{Inst}(\mathscr{P})$, except that more information
needs to flow through, since the adversary
also gets leakage information and routing control from $\mathscr{Q}$.
Furthermore, the interaction with $\mathscr{Q}$ is mediated
via the $S_i$, which exist because compatibility
only requires that the corruption in $\mathscr{Q}$ is at least as strong,
so these $S_i$ are there to weaken what the players in $\mathscr{P}$
have access to.

\subsection{Equality and Simulation}

In this subsection, we finally get to the various notions
of equality and simulation we've been foreshadowing.
To skip ahead a bit, we define three main notions here, which
are about claims that:
\begin{enumerate}
  \item two protocols behave identically,
  \item two protocols behave indistinguishably,
  \item one protocol is simulated by another.
\end{enumerate}
After defining these notions, we also show that all the kinds
of protocol composition we've defined respect these notions,
and satisfy a form of transitivity.
This allows us to make such claims about a large protocol,
by decomposing it into smaller protocols, and then making
several hops, appealing to claims about these smaller protocols.
This is analogous to the strategy that the state-separable proof
paradigm takes to proving things about game.
Indeed, this analogy is the principal motivation for this framework.

Like with packages and systems, two even compare two protocols,
they need to have the same shape.

\begin{definition}[Shape]
  \label{def:shape}
  We say that two protocols $\mathscr{P}, \mathscr{Q}$ have the same \emph{shape}
  if there exists a protocol $\mathscr{Q}' \equiv \mathscr{Q}$ such that:
  \begin{itemize}
    \item $\mathscr{P}.n = \mathscr{Q}'.n$,
    \item $\forall i \in [n].\quad \tx{In}(\mathscr{P}.P_i) = \tx{In}(\mathscr{Q}'.Q_i)$,
    \item $\forall i \in [n].\quad \tx{Out}(\mathscr{P}.P_i) = \tx{Out}(\mathscr{Q}'.Q_i)$,
    \item $\tx{Leakage}(\mathscr{P}) = \tx{Leakage}(\mathscr{Q}')$,
    \item $\tx{IdealIn}(\mathscr{P}) = \tx{IdealIn}(\mathscr{Q}')$.
  \end{itemize}

  $\square$
\end{definition}

The reason we use the $\mathscr{Q}'$ equivalent to $\mathscr{Q}$
is just so that we can get the order of players to be the same
as in $\mathscr{P}$.

The first notion of equality we capture is about arguing
that two protocols have the same behavior under a class of corruptions.

\begin{definition}[Semantic Equality]
  We say that two closed protocols $\mathscr{P}$ and $\mathscr{Q}$,
  with the same shape,
  are equal under a class of corruptions $\mathscr{C}$,
  written as $\mathscr{P} =_{\mathscr{C}} \mathscr{Q}$, when we have:
  $$
  \forall C \in \mathscr{C}.\quad \tx{Inst}_C(\mathscr{P}) = \tx{Inst}_C(\mathscr{Q}')
  $$
  as systems, with $\mathscr{Q}' \equiv \mathscr{Q}$ as per 
  Definition~\ref{def:shape}.

  $\square$

\end{definition}

For closed protocols, this is a more natural notion of equality
than $\equiv$, since it allows for behaviors
that are effectively identical, while not technically the same.

This notion is too strict for many protocols, which make
use of hard problems.
In this case, we want to appeal to indistinguishability instead.

\begin{definition}[Indistinguishability]
  We say that two closed protocols $\mathscr{P}$ and $\mathscr{Q}$,
  with the same shape,
  are \emph{indistinguishable} up to $\epsilon$ under a class of corruptions $\mathscr{C}$,
  written as $\mathscr{P} \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{Q}$, when we have:
  $$
  \forall C \in \mathscr{C}.\quad \tx{Inst}_C(\mathscr{P}) \overset{\epsilon}{\approx} \tx{Inst}_C(\mathscr{Q}')
  $$
  as systems, with $\mathscr{Q}' \equiv \mathscr{Q}$ as per 
  Definition~\ref{def:shape}.

  $\square$

\end{definition}

Like with systems and packages, this notion allows for
small differences, and restricts the adversary to only
have a limited amount of computation, allowing for hard
problems to exist, and be used inside the protocol.

The notions we've seen so far are natural extensions of the ones
we've defined for packages and systems.
This next notion, on the other hand, is novel.
This is the notion of \emph{simulation},
and is the typical kind of security claim made about protocols.
Simulation allows for many more protocols to be compared,
because it allows for a simulator $S$ to interface
between the adversary and one of the protocols.
The intuition here is that the simulator translates
attacks made on one protocol to attacks made on another.
If a protocol is simulated by a protocol under which
no attack is possible, then we can conclude that no
attack is possible against the concrete protocol,
since that would immediately translate into an attack against
the secure one.

To get to this notion of simulation, we first need to formally
define what a simulator is, and what it means to instantiate
a protocol with that simulator.

\begin{definition}[Simulated Instantiation]
  A simulator $S$ for a closed protocol $\mathscr{P}$ under a corruption
  model $C$ is a system satisfying:
  \begin{itemize}
    \item $\tx{InChan}(S), \tx{OutChan}(S) = \emptyset$,
    \item $\tx{In}(S) = \tx{Leakage} \cup \left(\bigcup_{C_i = \tx{M}} \tx{Out}(\tx{Corrupt}_{\tx{M}}(P_i))\right) \cup \left(\bigcup_{C_i = \tx{SH}} P_i.\tx{log}\right)$,
    \item $\tx{Out}(S) = \tx{In}(S)$,
  \end{itemize}

  Given such a simulator, we can define the simulated instantiation
  of $\mathscr{P}$ under $C$ with $S$ as:
  $$
  \tx{SimInst}_{S, C}(\mathscr{P}) := 
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(\tx{Out}(\tx{Inst}_C(\mathscr{P})) / \tx{Out}(S))
  \end{pmatrix}
  \circ \tx{Inst}_C(\mathscr{P})
  $$

  $\square$
\end{definition}

Basically, the simulator $S$ is allowed to touch all of the
``adversarial'' parts of the instantiation.
This is basically everything except the honest parts
of the protocol.
This includes the input functions for semi-honest parties,
but not their logs.
We can think of this simulator as translating attacks, as mentioned above.
We can also think of the simulator as trying to ``trick''
the adversary into thinking it's interacting
with one protocol, whereas in fact it's interacting with another.

This leads to a kind of notion of equality, called
\emph{simulation}.

\begin{definition}[Simulatability]
  Given closed protocols $\mathscr{P}, \mathscr{Q}$ with the same shape,
  we say that $\mathscr{P}$ is \emph{simulatable} up to $\epsilon$ by $\mathscr{Q}$
  under a class of corruptions $\mathscr{C}$,
  written as $\mathscr{P} \overset{\epsilon}{\leadsto}_{\mathscr{C}} \mathscr{Q}$,
  when:
  $$
  \forall C \in \mathscr{C}.\exists S.\quad \tx{Inst}_C(\mathscr{P}) \overset{\epsilon}{\approx} \tx{SimInst}_{S, C}(\mathscr{Q}')
  $$
  as systems, with $\mathscr{Q}' \equiv \mathscr{Q}$ as per 
  Definition~\ref{def:shape}.

  $\square$
\end{definition}

Note that this is not a symmetric notion.
There's a clear directionality to claims of simulation,
as indicated by the choice of notation.
One important technical detail is that the simulator can
depend on the specific corruption model.
In many cases, we even provide an explicit case-by-case proof,
using different simulator strategies for each kind of corruption.

As one might expect, these notions of equality and simulation
form a nice hierarchy, which we can formalize as follows.

\begin{theorem}[Equality Hierarchy]
  \label{thm:equality_hierarchy}
For any corruption class $\mathscr{C}$, we have:
\begin{enumerate}
\item $\mathscr{P} \equiv \mathscr{Q} \implies \mathscr{P} =_\mathscr{C} \mathscr{Q}$.
\item $\mathscr{P} =_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{0}{\approx}_\mathscr{C} \mathscr{Q}$.
\item $\mathscr{P} \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{\epsilon}{\leadsto}_\mathscr{C} \mathscr{Q}$.
\end{enumerate}

\txbf{Proof:}

\txbf{1.} 
For any $C \in \mathscr{C}$, $\tx{Corrupt}_{C}$ and $\tx{Routed}$ are equality respecting,
so we have:
$$
\forall i \in [n].\quad \tx{Routed}(\tx{Corrupt}_C(\mathscr{P}.P_i)) = 
\tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}.P_i))
$$

Furthermore, the equality of players between $\mathscr{P}$ and $\mathscr{Q}$
makes $\mathscr{P}.\mathcal{R} = \mathscr{Q}.\mathcal{R}$.

And then, the fact that $\mathscr{P}.F = \mathscr{Q}.F$ forces $\tx{Leakage}$
to be the same as well.

Finally, since $\circ, *, \otimes$ are respect $\equiv$, we
can clearly see that $\tx{Inst}_C(\mathscr{P}) = \tx{Inst}_C(\mathscr{Q})$,
since all the sub-components are literally equal.

\txbf{2.} For any systems $A, B$, we have $A = B \implies A \overset{0}{\approx} B$.
Applying this to $\tx{Inst}_C(\mathscr{P})$ and $\tx{Inst}_C(\mathscr{Q})$
gives us our result.

\txbf{3.} It suffices to define a simulator $S$ such that
$\tx{SimInst}_{S, C}(\mathscr{Q}) = \tx{Inst}_C(\mathscr{Q})$,
which will then show our result.
We can simply take $S = 1(\ldots)$ for the right set.

$\blacksquare$
\end{theorem}

The fact that equality implies indistinguishability is unsurprising,
since we've seen that hold already for packages and systems.
For simulation, the key to the proof was that you can
define a simulator that doesn't do anything, in which
case indistinguishability and simulation are effectively the same.

For these equality notions to be useful, we also want some kind of transitivity,
so that we can decompose proofs into smaller hops.
Thankfully, we also have analogous notions of transitivity.

\begin{theorem}[Transitivity of Equality]
  \label{thm:prot_trans}
  For any closed protocols $\mathscr{L}, \mathscr{P}, \mathscr{Q}$ with the same shape,
  and any class of corruptions $\mathscr{C}$, we have:
  \begin{enumerate}
    \item $\mathscr{L} =_{\mathscr{C}} \mathscr{P}, \mathscr{P} =_{\mathscr{C}} \mathscr{Q} \implies \mathscr{L} =_{\mathscr{C}}\mathscr{Q}$,
    \item $\mathscr{L} \overset{\epsilon_1}{\approx}_{\mathscr{C}} \mathscr{P}, \mathscr{P} \overset{\epsilon_2}{\approx}_{\mathscr{C}} \mathscr{Q} \implies \mathscr{L} \overset{\epsilon_1 + \epsilon_2}{\approx}_{\mathscr{C}} \mathscr{Q}$,
    \item $\mathscr{L} \overset{\epsilon_1}{\leadsto}_{\mathscr{C}} \mathscr{P}, \mathscr{P} \overset{\epsilon_2}{\leadsto}_{\mathscr{C}} \mathscr{Q} \implies \mathscr{L} \overset{\epsilon_1 + \epsilon_2}{\leadsto}_{\mathscr{C}} \mathscr{Q}$.
  \end{enumerate}

  \txbf{Proof:} The first two parts follow directly from Lemma~\ref{thm:system_trans} (
    transitivity for system equality
  ).
  Indeed, we just look at $\tx{Inst}_C(\mathscr{L})$, $\tx{Inst}_C(\mathscr{P})$, and $\tx{Inst}_C(\mathscr{Q})$
  as systems, for any corruption model $C$.

  For part 3, by assumption we have, for any $C \in \mathscr{C}$:
  \begin{itemize}
  \item $\tx{Inst}_C(\mathscr{L}) \overset{\epsilon_1}{\approx} \begin{pmatrix} S_1\cr \otimes\cr 1(O)\end{pmatrix} \tx{Inst}_C(\mathscr{P})$,
  \item $\tx{Inst}_C(\mathscr{P}) \overset{\epsilon_1}{\approx} \begin{pmatrix} S_2\cr \otimes\cr 1(O)\end{pmatrix} \tx{Inst}_C(\mathscr{Q})$.
  \end{itemize}
  This means that:
  $$
  \tx{Inst}_C(\mathscr{L}) \overset{\epsilon_1 + \epsilon_2}{\approx}
  \begin{pmatrix}
    S_1 \cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S_2 \cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}_C(\mathscr{Q})
  $$
  applying the properties we have for systems.

  Then, we can apply interchange to write this as:
  $$
  \begin{pmatrix}
    S_1 \circ S_2 \cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}_C(\mathscr{Q})
  $$
  which concludes our proof, since $S_1 \circ S_2$ will be a valid simulator.

  $\blacksquare$
\end{theorem}

The crux of the proof was that simulators compose together,
which allows simulation to become transitive.
As we've seen for packages and systems, transitivity is
a critical part of what makes proofs more modular.

From the definitions we've seen so far, it's necessary
to consider both semi-honest and malicious corruption,
if the class happens to include them.
It turns out that for $=$ and $\approx$, we can always
disregard semi-honest corruption in favor of malicious corruption,
and in some cases we can also do this for simulation as well.

\begin{theorem}[Malicious Completeness]
  \label{thm:mal_complete}
  Let $\mathscr{P}$ and $\mathscr{Q}$ closed protocols with the same shape.
  Given any class of corruptions $\mathscr{C}$, let $\mathscr{C}'$ be a related class, containing
  models in $\mathscr{C}$ with some
  malicious corruptions replaced with semi-honest corruptions.
  We then have:
  \begin{enumerate}
    \item $\mathscr{P} =_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} =_{\mathscr{C}'} \mathscr{Q}$,
    \item $\mathscr{P} \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{\epsilon}{\approx}_{\mathscr{C}'} \mathscr{Q}$,
  \end{enumerate}
  Furthermore, if for any $C \in \mathscr{C}$ and its related model $C' \in \mathscr{C}$,
  there exists a simulator $S_{\tx{M}}$ such that $\tx{Inst}_C(\mathscr{Q}) = \tx{SimInst}_{S_{\tx{M}}, C'}(\mathscr{Q})$,
  then it additionally holds that:
  \begin{enumerate}
    \setcounter{enumi}{2}
    \item $\mathscr{P} \overset{\epsilon}{\leadsto}_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{\epsilon}{\leadsto}_{\mathscr{C}'} \mathscr{Q}$
  \end{enumerate}

  \txbf{Proof:} Lemma~\label{thm:simulatingcorruption} (simulating corruptions) is the crux of our proof.
  It implies that there exists a system $S_{\tx{SH}}$ such that
  $$
  \tx{Corrupt}_{\tx{SH}}(P) = S_{\tx{SH}} \circ \tx{Corrupt}_M(P)
  $$

  As a consequence, for any $C' \in \mathscr{C}'$ and the $C \in \mathscr{C}$ it's related to,
  there exists a \emph{simulator} $S_{\tx{SH}}$ such that:
  $$
  \tx{Inst}_{C'}(\mathscr{P}) =
  \begin{pmatrix}
    S_{\tx{SH}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ \tx{Inst}_{C}(\mathscr{P})
  $$
  which simulates all of the semi-honest corruptions in $C'$ from the malicious ones in $C$.

  This immediately implies parts 1 and 2, by the fact that $\circ$ for systems
  respects equality and indistinguishability.

  For part 3, we apply the assumption in the implication to get:
  $$
  \begin{pmatrix}
    S_{\tx{SH}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ \tx{Inst}_{C}(\mathscr{Q})
  $$
  Then, apply our assumption about being able to simulate malicious corruption
  from semi-honest corruption to get:
  $$
  \begin{pmatrix}
    S_{\tx{SH}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S_M\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ \tx{Inst}_{C'}(\mathscr{Q})
  $$
  which we can then apply interchange to to end up with:
  $$
  \begin{pmatrix}
    S_{\tx{SH}} \circ S \circ S_M\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ \tx{Inst}_{C'}(\mathscr{Q})
  = \tx{SimInst}_{S', C'}(\mathscr{Q})
  $$
  for $S' := S_{\tx{SH}} \circ S \circ S_M$, concluding our proof.

  $\blacksquare$
\end{theorem}

For simulation, unfortunately we get stuck in the proof without the additional
assumption.
The fundamental issue is that malicious corruption helps both
the adversary and the simulator.
The simulator might make use of the extra powers they get
from malicious corruption, which are then no longer available
to them in the semi-honest case.
One particular power is the ability to change the input being
provided, as noted in
\cite{EPRINT:HazLin10a}, which provides
some example protocols secure under malicious, but not semi-honest corruption.
The condition we've added might seem a bit odd, being able to simulate
semi-honest corruption from malicious corruption,
but it does actually show up somewhat often
For example, if a protocol just consists of calling part of an ideal
functionality, then semi-honest and malicious corruption
are the same, as we'll see later.

The next step will be to show how the various notions of composition
we've defined interact with these notions of equality and simulation.
Thankfully, all of the ways of composing protocols
respect both equality and simulation in the natural ways,
allowing the use of modular proofs like the ones we can create
for packages.

First, we look at composing protocols with functionalities.

\begin{theorem}[Vertical Composition Theorem]
  \label{thm:vertical_composition_theorem}
  For any protocol $\mathscr{P}$ and game $G$, such that $\mathscr{P} \circ G$
  is well defined and closed, and for any corruption class $\mathscr{C}$, we have:
  \begin{enumerate}
    \item $G = G' \implies \mathscr{P} \circ G =_{\mathscr{C}} \mathscr{P} \circ G'$
    \item $G \overset{\epsilon}{\approx} G' \implies \mathscr{P} \circ G \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{P} \circ G'$
  \end{enumerate}
  
\txbf{Proof:} We start by noting that $\tx{Inst}_C(\mathscr{P} \circ G) = A \circ F \circ G$,
for some system $A$.
Part 1 follows immediately from this, since $\circ$ is equality respecting.

Part 2 follows by applying Lemma~\ref{lemma:systemcomposition},
which entails that for any system $S$, we have $S \circ G \overset{\epsilon}{\approx} S \circ G'$.

$\blacksquare$
\end{theorem}

This property is quite useful, since it allows separating out part
of a functionality, and then appealing to the indistinguishability
of two games, to argue that one protocol simulates another.
This allows a kind of bridging between gamed based proofs
and protocols, allowing us to make
use of indistinguishability proofs for games to aid
in proving properties of protocols.

Next, we look at composing protocols concurrently.
We'll need to use the notion of compatibility for corruption
classes that we've defined before.

\begin{theorem}[Concurrent Composition Theorem]
  Let $\mathscr{P}, \mathscr{Q}$ be protocols, with $\mathscr{P} \otimes \mathscr{Q}$
  well defined and closed. For any compatible corruption classes $\mathscr{C}, \mathscr{C}'$
  it holds that:
  \begin{enumerate}
    \item $\mathscr{Q} =_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \otimes \mathscr{Q} =_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$
    \item $\mathscr{Q} \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \otimes \mathscr{Q} \overset{\epsilon}{\approx}_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$
    \item $\mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \otimes \mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$
  \end{enumerate}

  \txbf{Proof:} Theorem~\ref{thm:concurrent_breakdown} (concurrent breakdown)
  will be essential to our proof.
  This implies that $\forall C \in \mathscr{C}$, then for any compatible $C' \in \mathscr{C}'$
  we have:
  $$
  \tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}) = \tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_{C}(\mathscr{Q})
  $$

\txbf{1.}
Since $\mathscr{Q} =_{\mathscr{C}} \mathscr{Q}'$, we have $\forall C \in \mathscr{C}.\ \tx{Inst}_C(\mathscr{Q}) = \tx{Inst}_C(\mathscr{Q}')$.
Now, consider any $C' \in \mathscr{C}'$.
By our assumption that $\mathscr{C}'$ is compatible with $\mathscr{C}$,
there exists a $C \in \mathscr{C}$ that $C'$ is compatible with.
Using concurrent breakdown, we then have:
$$
\tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}) =
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q})
$$
Then, since $\mathscr{Q} =_{\mathscr{C}} \mathscr{Q}'$, we have:
$$
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q}) =
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q}') =
\tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}')
$$
concluding our proof.

\txbf{2.}
The proof here is similar to part 1.
For any $C' \in \mathscr{C}'$, there exists a compatible $C \in \mathscr{C}$,
and then we get:
$$
\tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}) =
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q})
$$
Since $\mathscr{Q} \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{Q}'$,
we have:
$$
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q})
\overset{\epsilon}{\approx} 
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q}')
$$
since $\otimes$ for systems respects this operation.
We can then conclude with
$$
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q}') =
\tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}')
$$

\txbf{3.} Once more, for any $C' \in \mathscr{C}'$, there exists a compatible
$C \in \mathscr{C}$ giving us:
$$
\tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q}) =
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q})
$$
We then apply our assumption that $\mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}} \mathscr{Q}'$
to get:
$$
\tx{Inst}_{C'}(\mathscr{P}) \otimes \tx{Inst}_C(\mathscr{Q})
\overset{\epsilon}{\approx}
\tx{Inst}_{C'}(\mathscr{P}) \otimes ((S \otimes 1(\ldots)) \circ \tx{Inst}_C(\mathscr{Q}'))
$$
Next, we apply interchange to get:
$$
\begin{matrix}
1(\tx{Out}(\tx{Inst}_{C'}(\mathscr{P}))) \circ \tx{Inst}_{C'}(\mathscr{P})\cr
\otimes\cr
((S \otimes 1(\ldots)) \circ \tx{Inst}_C(\mathscr{Q}'))
\end{matrix}
=
\begin{pmatrix}
1(\tx{Out}(\tx{Inst}_{C'}(\mathscr{P})))\cr
\otimes\cr
S\cr
\otimes\cr
1(\tx{Out}(\tx{Inst}_C(\mathscr{Q})) / \tx{Out}(S))
\end{pmatrix}
\circ
\begin{pmatrix}
  \tx{Inst}_{C'}(\mathscr{P})\cr
  \otimes\cr
  \tx{Inst}_{C}(\mathscr{Q}')
\end{pmatrix}
$$
Applying concurrent breakdown in reverse, we get that the right hand
side is $\tx{Inst}_{C'}(\mathscr{P} \otimes \mathscr{Q})$,
and that the left hand side is the simulator showing
that $\mathscr{P} \otimes \mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$.
The left hand side is a valid simulator because
$\tx{Out}(\tx{Inst}_C(\mathscr{Q})) = \tx{Out}(\tx{Inst}_{C'}(\mathscr{Q}))$,
and all of the honest parts of $\mathscr{P}$ are left untouched,
since all of it is.

$\blacksquare$
\end{theorem}

Critically, the use of the concurrent breakdown theorem was
essential in proving this theorem.
Basically, all the hard work had already been done,
and we just need to apply some of the notions we've developed
for systems to finish the details of the proof.

Finally, we can look horizontal composition of protocols.
Like with the breakdown theorems, this one is a tad more complicated,
and is where we need to deploy the notion of \emph{strict}
compatibility we developed earlier.

\begin{theorem}[Horizontal Composition Theorem]
  \label{thm:horizontal_composition_theorem}
  For any protocols $\mathscr{P}, \mathscr{Q}$ with $\mathscr{P} \lhd \mathscr{Q}$
  well defined and closed, and for any compatible corruption classes $\mathscr{C}, \mathscr{C'}$, we have:
  \begin{enumerate}
    \item $\mathscr{Q} =_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \lhd \mathscr{Q} =_{\mathscr{C}'} \mathscr{P} \lhd \mathscr{Q}'$
    \item $\mathscr{Q} \overset{\epsilon}{\approx}_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \lhd \mathscr{Q} \overset{\epsilon}{\approx}_{\mathscr{C}'} \mathscr{P} \lhd \mathscr{Q}'$
  \end{enumerate}

  Furthermore, if $\mathscr{C}'$ is \emph{strictly} compatible with $\mathscr{C}$,
  we have:
  \begin{enumerate}
    \setcounter{enumi}{2}
    \item $\mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \lhd \mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}'} \mathscr{P} \lhd \mathscr{Q}'$
  \end{enumerate}

  \txbf{Proof:} As one might expect,
  Theorem~\ref{thm:horizontal_breakdown}(horizontal breakdown)
  will be critical to proving each of these statements.

  One crude summary of the theorem, in the case
  that the protocols are closed, is that given compatible
  corruption models $C, C'$, there's a system $\tx{Stuff}$ such that
  $$
  \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}) = \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q})
  $$
  This summary suffices to prove a couple statements already.

  \txbf{1.} By assumption, for any $C' \in \mathscr{C}'$,
  there exists a compatible $C \in \mathscr{C}$.
  In this case, we have:
  $$
  \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}) = \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q})
  $$
  If we then apply $\mathscr{Q} =_{\mathscr{C}} \mathscr{Q}'$,
  we get:
  $$
  \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q}) = \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q}')
  $$
  and then, applying breakdown in reverse, we end up with $\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}')$,
  completing our proof.

  \txbf{2.} We apply the same reasoning, with the difference that:
  $$
  \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q}) \overset{\epsilon}{\approx} \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q}')
  $$
  rather than being strictly equal.

  \txbf{3.} At this point our crude summary of the breakdown theorem is not
  sufficient anymore.
  We start with the same reasoning.
  For any $C' \in \mathscr{C}'$, there exists a \emph{strictly}
  compatible $C \in \mathscr{C}$, and we have:
  $$
  \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}) = \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q})
  $$
  then, we apply our assumption that $\mathscr{Q} \overset{\epsilon}{\leadsto}_{\mathscr{C}} \mathscr{Q}'$,
  giving us:
  $$
  \tx{Stuff} \circ \tx{Inst}_C(\mathscr{Q}) \overset{\epsilon}{\approx} \tx{Stuff} \circ (S \otimes 1(\ldots)) \circ \tx{Inst}_C(\mathscr{Q})
  $$
  Our strategy will be to rearrange the right hand side to get
  $$
  {(S' \otimes 1(\ldots)) \circ \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}')}
  $$
  We start by unrolling $\tx{Stuff}$, using strict compatibility, to get:
  $$
  1(O)\circ
  \begin{pmatrix}
    {\displaystyle \bigast}_{i \in [\mathscr{P}.n]} \tx{Routed}(\tx{Corrupt}'_{C'}(\mathscr{P}.P_i))
    \cr
    *\cr
    \mathcal{R}_{\mathscr{P}}\cr
    \otimes\cr
    1(\tx{Leakage}, L_{\mathscr{Q}'})
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \mathscr{P}.F\cr
    \otimes\cr
    1(\tx{Out}(\mathcal{R}_q))\cr
    \otimes\cr
    1(\mathscr{Q}'.\tx{Leakage})\cr
    \otimes\cr
    \bigotimes_{i \in [\mathscr{Q}'.n]} 1_i\cr
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(O_{\bar{S}})
  \end{pmatrix}
  \circ
  \tx{Inst}_C(\mathscr{Q}')
  $$
  with $O_{\bar{S}} := \tx{Out}(\tx{Inst}_C(\mathscr{Q}')) / \tx{Out}(S)$,
  and with each $1_i := 1(\tx{Out}(\tx{Inst}_C(\mathscr{Q}'.P_i)))$.
  we can apply interchange a few times to get:
  $$
  \footnotesize
  1(O) \circ
  \begin{pmatrix}
    \begin{pmatrix}
    {\displaystyle \bigast_{C'_i \neq \tx{H}}}
    \begin{pmatrix}
      \tx{Routed}(\tx{Corrupt}'_{C'}(\mathscr{P}.P_i))\cr
      \otimes\cr
      1(L_i)
    \end{pmatrix}\cr
    \otimes\cr
    1(\tx{Leakage})
    \end{pmatrix}
    \circ
    \begin{pmatrix}
      S\cr
      \otimes\cr
      1(O_S)
    \end{pmatrix}
    \circ
    \begin{pmatrix}
    {\displaystyle \bigast_{C_i \neq \tx{H}}}
    \tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}'.P_i))
    \cr
    \otimes\cr
    1(\tx{Out}(\mathscr{P}.F), \tx{Out}(\mathscr{Q}.F))
    \end{pmatrix}
    \cr
    *\cr
    {\displaystyle \bigast_{C'_i = \tx{H}}}
    \tx{Routed}(\tx{Corrupt}_{C'}((\mathscr{P} \lhd \mathscr{Q}').P_i))\cr
    *\cr
    \mathcal{R}_{\mathscr{P}} \circ \mathcal{R}_{\mathscr{Q}'}\cr
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \mathscr{P}.F\cr
    \otimes\cr
    \mathscr{Q}'.F
  \end{pmatrix}
  $$
  with $O_S := O_{\bar{S}} \cup \tx{Out}(\mathscr{P}.F)$ and $L_i$ as per the horizontal breakdown theorem.
  The only functions that $S$ masks are the leakage, the malicious corruption
  functions, and the logs from semi-honest corruption.
  Semi-honest corruption does not use any outputs of $S$,
  instead relying on the $\mathscr{Q}'.P_i$, accessible via $1(O_S)$.
  In the case of malicious corruption, since $\tx{Corrupt}'_{C'}(\mathscr{P}.P_i)$
  omits the $\tx{Call}_{F_i}$ functions, the system also has no dependencies
  on the output of $S$.
  Since none of these corrupted players depend on $S$,
  we can slide it forward, using interchange, to get:
  $$
  \footnotesize
  1(O) \circ
  \begin{pmatrix}
    \begin{pmatrix}
      S\cr
      \otimes\cr
      1(\ldots)
    \end{pmatrix}
    \circ
    \begin{pmatrix}
    {\displaystyle \bigast_{C'_i \neq \tx{H}}}
    \begin{pmatrix}
      \tx{Routed}(\tx{Corrupt}'_{C'}(\mathscr{P}.P_i))\cr
      \otimes\cr
      1(L_i)
    \end{pmatrix}\cr
    \otimes\cr
    1(\tx{Leakage})
    \end{pmatrix}
    \circ
    \begin{pmatrix}
    {\displaystyle \bigast_{C_i \neq \tx{H}}}
    \tx{Routed}(\tx{Corrupt}_C(\mathscr{Q}'.P_i))
    \cr
    \otimes\cr
    1(\tx{Out}(\mathscr{P}.F), \tx{Out}(\mathscr{Q}.F))
    \end{pmatrix}
    \cr
    *\cr
    {\displaystyle \bigast_{C'_i = \tx{H}}}
    \tx{Routed}(\tx{Corrupt}_{C'}((\mathscr{P} \lhd \mathscr{Q}').P_i))\cr
    *\cr
    \mathcal{R}_{\mathscr{P}} \circ \mathcal{R}_{\mathscr{Q}'}\cr
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \mathscr{P}.F\cr
    \otimes\cr
    \mathscr{Q}'.F
  \end{pmatrix}
  $$
  which becomes:
  $$
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(\tx{Out}(\tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}')) / \tx{Out}(S))
  \end{pmatrix}
  \circ
  \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q}')
  $$

  From this chain of equalities we conclude that
  $\mathscr{P} \lhd \mathscr{Q}' \overset{\epsilon}{\leadsto} \mathscr{P} \lhd \mathscr{Q}'$

  $\blacksquare$
\end{theorem}

The reason we needed strict compatibility was that we needed
to move the simulator $S$ for $\mathscr{Q}$, to instead
become a simulator for $\mathscr{P}$.
When we have strictly compatible corruption, there are no barriers
to doing this, since $S$ is able to get all the information
it needs about $\mathscr{Q}$ via $\mathscr{P} \lhd \mathscr{Q}$.
However, if we don't have strict compatibility,
we might run into the issue that $S$ requires a stronger kind
of corruption than $\mathscr{P}$ ends up using,
and so we wont be able to move $S$ to the left hand side,
as we did here.
This is why we demand strict compatibility.
In practice, this condition shouldn't be very demanding,
because in many cases the number of parties is the same for both protocols,
or we're focusing on a complete corruption class, like ``up to $n - 1$ corruptions''.

At this point, we've defined the crux of our modular framework for protocols.
We've defined the common notion of simulation, which is usually
the kind of statement we want to prove.
Furthermore, we've shown that the various means of composing
protocols respect this simulation.
So, if one small part of a protocol is simulated by another,
then we can argue that a larger protocol making use of the component
will be simulated by replacing this component.
This allows reasoning about large protocols via small components,
and makes composing isolated protocols into larger systems
in a secure way much easier.
Furthermore, the framework we've defined so far
also integrates nicely with games, since ideal functionalities
are simply packages.
We can even use notions of indistinguishability for these functionalities
to argue that the protocols that use them simulate one another.

\subsection{Global Functionalities}

Next, we redo a bit of what we've developed so far, this time
with the goal of incorporating \emph{global functionalities}.
The basic example one should have in mind throughout this section
is that of a hash function, treated as a \emph{global random oracle}.
This hash can be used by various protocols, but yet it should
be treated as one common random oracle throughout all of the protocols.
We need a notion of simulation which can account for this reality.
Basically, we want to say that one protocol simulates another,
even in the presence of a shared random oracle,
and this notion of simulation should have the nice composability properties
that we've come to expect.

This development does involve rehashing some of the work
we've done in the previous subsection.
We could have avoided some of the repetition here,
but we feel like having a separate subsection provides more clarity,
especially since in many cases a global functionality isn't being used.

First, when a protocol depends on a global functionality,
this is because it isn't closed.
This dependency will be from the fact that its ideal functionality
still has some dependencies on the global functionality.

We can formalize this kind of ``closed but for the global functionality''
notion.

\begin{definition}[Relatively Closed Protocols]
  A protocol $\mathscr{P}$ is \emph{closed relative to} a game $G$
  if:
  \begin{itemize}
    \item $\tx{In}(\mathscr{P}) = \emptyset$
    \item $\tx{IdealIn}(\mathscr{P}) \subseteq \tx{Out}(G)$
  \end{itemize} 

  $\square$
\end{definition}

As one might expect, we now define notions of instantiation
and equality for such relatively closed protocols.

\begin{definition}[Relative Instantiation]
  Given a closed protocol $\mathscr{P}$ relative to $G$, we can define,
  for any corruption model $C$,
  the relative instantiation:
  $$
  \tx{Inst}_{C}^G(\mathscr{P}) :=
  \begin{pmatrix}
    \tx{Inst}_C(\mathscr{P})\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  $$

  We can also extend this to the case of simulated instantiation,
  defining, for any simulator $S$:
  $$
  \tx{SimInst}_{S, C}^G(\mathscr{P}) :=
  \begin{pmatrix}
    \tx{SimInst}_{S, C}(\mathscr{P})\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  $$

  $\square$
\end{definition}

One key aspect of relative instantiation is that the adversary
is always able to interact with $G$ completely.
Going back to our example of the hash function,
this would also be the case.
The adversary is able to call the global random oracle at will.
This complete access is key to composability.

We can now use relative instantiation to define the same notions
of equality that we did for standard protocols and regular instantiation.

\begin{definition}[Relative Notions of Equality]
  Given closed protocols $\mathscr{P}, \mathscr{Q}$ relative to $G$,
  with the same shape, and a corruption class $\mathscr{C}$
  for these protocols, we define:
  \begin{itemize}
    \item $\mathscr{P} =^G_{\mathscr{C}} \mathscr{Q} \iff \forall C \in \mathscr{C}.\ \tx{Inst}^G_C(\mathscr{P}) = \tx{Inst}^G_C(\mathscr{Q})$
    \item $\mathscr{P} \overset{\epsilon}{\approx}^G_{\mathscr{C}} \mathscr{Q}\iff \forall C \in \mathscr{C}.\ \tx{Inst}^G_C(\mathscr{P}) \overset{\epsilon}{\approx} \tx{Inst}^G_C(\mathscr{Q})$
    \item $\mathscr{P} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}} \mathscr{Q}\iff \forall C \in \mathscr{C}.\ \exists S.\ \tx{Inst}^G_C(\mathscr{P}) \overset{\epsilon}{\approx} \tx{SimInst}^G_{S,C}(\mathscr{Q})$
  \end{itemize}

  $\square$
\end{definition}

These are all the same, except for the replacement of instantiation
with relative instantiation with respect to $G$.
As one might expect, the same kind of equality hierarchy also holds
here as well.

\begin{theorem}[Relative Equality Hierarchy]
  For any corruption class $\mathscr{C}$ and game $G$, we have:
\begin{enumerate}
\item $\mathscr{P} =^G_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{0}{\approx}^G_\mathscr{C} \mathscr{Q}$.
\item $\mathscr{P} \overset{\epsilon}{\approx}^G_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{\epsilon}{\leadsto}^G_\mathscr{C} \mathscr{Q}$.
\end{enumerate}
\txbf{Proof:}

\txbf{1.} This follows from the fact that $A = B \implies A \overset{0}{\approx} B$
for any systems $A, B$.

\txbf{2.} In the proof of Theorem~\ref{thm:equality_hierarchy},
we used the existence of a simulator $S$ such that $\tx{SimInst}_{S, C}(\mathscr{P}) = \tx{Inst}_C(\mathscr{P})$.
This simulator will also satisfy $\tx{SimInst}^G_{S, C}(\mathscr{P}) = \tx{Inst}^G_C(\mathscr{P})$,
and can thus be used directly to prove this relation.

$\blacksquare$
\end{theorem}

Furthermore, these notions of equality are transitive in the exact same way
as before.

\begin{theorem}[Transitivity of Relative Equality]
  \label{thm:trans_relative_equality}
  For any protocols $\mathscr{L}$, $\mathscr{P}$, $\mathscr{Q}$
  closed relative to a game $G$, and for any corruption class, we have:
  \begin{enumerate}
    \item $\mathscr{L} =_{\mathscr{C}}^G \mathscr{P}, \mathscr{P} =_{\mathscr{C}}^G \mathscr{Q} \implies \mathscr{L} =_{\mathscr{C}}^G \mathscr{Q}$,
    \item $\mathscr{L} \overset{\epsilon_1}{\approx}_{\mathscr{C}}^G \mathscr{P}, \mathscr{P} \overset{\epsilon_2}{\approx}_{\mathscr{C}}^G \mathscr{Q} \implies \mathscr{L} \overset{\epsilon_1 + \epsilon_2}{\approx}_{\mathscr{C}}^G \mathscr{Q}$,
    \item $\mathscr{L} \overset{\epsilon_1}{\leadsto}_{\mathscr{C}}^G \mathscr{P}, \mathscr{P} \overset{\epsilon_2}{\leadsto}_{\mathscr{C}}^G \mathscr{Q} \implies \mathscr{L} \overset{\epsilon_1 + \epsilon_2}{\leadsto}_{\mathscr{C}}^G \mathscr{Q}$.
  \end{enumerate}

  \txbf{Proof:} Once again, the first two parts follow directly from Lemma~\ref{thm:system_trans},
  by considering the systems $\tx{Inst}^G_C(\mathscr{L})$, $\tx{Inst}^G_C(\mathscr{P})$,
  $\tx{Inst}^G_C(\mathscr{Q})$ for any $C \in \mathscr{C}$.

  For part 3, given any $C \in \mathscr{C}$, there exists $S_1, S_2$ such that:
  \begin{itemize}
    \item $\tx{Inst}^G_C(\mathscr{L}) \overset{\epsilon_1}{\approx} \tx{SimInst}^G_{S_1, C}(\mathscr{P})$,
    \item $\tx{Inst}^G_C(\mathscr{P}) \overset{\epsilon_2}{\approx} \tx{SimInst}^G_{S_2, C}(\mathscr{Q})$.
  \end{itemize}
  Next, observe that for any protocol $\mathscr{P}$, we can write:
  $$
  \tx{SimInst}^G_C =
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}^G_C(\mathscr{P})
  $$
  where $O = \tx{Out}(\tx{Inst}_C(\mathscr{P})) / \tx{Out}(S) \cup \tx{Out}(G)$.

  We then apply transitivity for systems and interchange get:
  $$
  \tx{Inst}^G_C(\mathscr{L}) \overset{\epsilon_1 + \epsilon_2}{\approx}
  \begin{pmatrix}
    S_1 \circ S_2\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}^G_C(\mathscr{Q})
  $$
  And the left side is simply $\tx{SimInst}^G_{(S_1 \circ S_2), C}(\mathscr{Q})$,
  concluding our proof.

  $\blacksquare$
\end{theorem}

In many cases, we want to avoid proving semi-honest security
explicitly, if we can get away with just proving malicious security.
Thankfully, the same observation we made for standalone protocols
also applies to ones that use a global functionality.

\begin{theorem}[Global Malicious Completeness]
  Let $\mathscr{P}$ and $\mathscr{Q}$ closed protocols relative to $G$ with the same shape.
  Given any class of corruptions $\mathscr{C}$, let $\mathscr{C}'$ be a related class, containing
  models in $\mathscr{C}$ with some
  malicious corruptions replaced with semi-honest corruptions.
  We then have:
  \begin{enumerate}
    \item $\mathscr{P} =^G_{C} \mathscr{Q} \implies \mathscr{P} =^G_{C'} \mathscr{Q}$,
    \item $\mathscr{P} \overset{\epsilon}{\approx}^G_{C} \mathscr{Q} \implies \mathscr{P} \overset{\epsilon}{\approx}^G_{C'} \mathscr{Q}$,
  \end{enumerate}

  Furthermore, if for any $C \in \mathscr{C}$ and its related model $C' \in \mathscr{C}$,
  there exists a simulator $S_{\tx{M}}$ such that $\tx{Inst}^G_C(\mathscr{Q}) = \tx{SimInst}^G_{S_{\tx{M}}, C'}(\mathscr{Q})$,
  then it additionally holds that:
  \begin{enumerate}
    \setcounter{enumi}{2}
    \item $\mathscr{P} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}} \mathscr{Q} \implies \mathscr{P} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}'} \mathscr{Q}$
  \end{enumerate}

  \txbf{Proof:} We proceed similarly to Theorem~\ref{thm:mal_complete} (malicious completeness).
  In that theorem, the key observation was that for any $C' \in \mathscr{C}'$
  and the related $C \in \mathscr{C}$, it holds that:
  $$
  \tx{Inst}_{C'}(\mathscr{P}) = \tx{SimInst}_{S_{\tx{SH}}, C}(\mathscr{P})
  $$
  (this observation also doesn't depend on $\mathscr{P}$ being fully closed,
  allowing us to use it here).

  Now, this clearly implies that:
  $$
  \tx{Inst}_{C'}^G(\mathscr{P}) = \tx{SimInst}^G_{S_{\tx{SH}}, C}(\mathscr{P})
  $$
  And then, using our observation from Theorem~\ref{thm:trans_relative_equality},
  we can write this as:
  $$
  \tx{Inst}_{C'}^G(\mathscr{P}) =
  \begin{pmatrix}
    S_{\tx{SH}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}^G_C(\mathscr{P})
  $$
  where $O = \tx{Out}(\tx{Inst}_C(\mathscr{P})) / \tx{Out}(S) \cup \tx{Out}(G)$.

  This immediately implies parts 1 and 2.

  For part 3, apply the assumption in the implication to get:
  $$
  \begin{pmatrix}
    S_{\tx{SH}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}^G_C(\mathscr{Q})
  $$
  Then apply the assumption about being able to simulate malicious corruption to
  get:
  $$
  \begin{pmatrix}
    S_{\tx{SH}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    S_{\tx{M}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}^G_{C'}(\mathscr{Q})
  $$
  which can then be rearranged with interchange to get:
  $$
  \begin{pmatrix}
    S_{\tx{SH}} \circ S \circ S_{\tx{M}}\cr
    \otimes\cr
    1(O)
  \end{pmatrix}
  \circ
  \tx{Inst}^G_{C'}(\mathscr{Q})
  $$
  And then if we apply the same observation about $\tx{SimInst}^G$, we realize
  that this is:
  $$
  \tx{SimInst}^G_{(S_{\tx{SH}} \circ S \circ S_{\tx{M}}), C'}(\mathscr{Q})
  $$
  concluding our proof.

  $\blacksquare$
\end{theorem}

As we've foreshadowed, our next task will be to prove
that the various notions of composition we have
respect the relative notions of equality we've developed.
Thankfully, our restriction that the adversary
can access the entirety of the global functionality makes
these theorems easy to prove.
Since we've already seen these theorems before, in the standalone
context, we won't provide much commentary.
The proofs are usually based on the proofs in the previous subsection
as well.

\begin{theorem}[Global Vertical Composition Theorem]
  For any protocol $\mathscr{P}$ and game $F$, such that $\mathscr{P} \circ F$
  is well defined and closed relative to $G$, and for any corruption class $\mathscr{C}$, we have:
  \begin{enumerate}
    \item $F = F' \implies \mathscr{P} \circ F =^G_{\mathscr{C}} \mathscr{P} \circ F'$
    \item $F \overset{\epsilon}{\approx} F' \implies \mathscr{P} \circ F \overset{\epsilon}{\approx}^G_{\mathscr{C}} \mathscr{P} \circ F'$
  \end{enumerate}

  \txbf{Proof:} The proof of Theorem~\ref{thm:vertical_composition_theorem} will be the basis
  for what we do here.
  Using it, we can write:
  $$
  \tx{Inst}^G_C(\mathscr{P} \circ F) =
  \begin{pmatrix}
    A \circ F\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  $$
  for some system $A$.
  At this point, the theorem immediately holds, since $\circ$ and $\otimes$ (for systems)
  respect both $=$ and $\approx$.

  $\blacksquare$
\end{theorem}

\begin{theorem}[Global Concurrent Composition Theorem]
  Let $\mathscr{P}, \mathscr{Q}$ be closed protocols relative to $G$, with $\mathscr{P} \otimes \mathscr{Q}$
  well defined. For any compatible corruption classes $\mathscr{C}, \mathscr{C}'$
  it holds that:
  \begin{enumerate}
    \item $\mathscr{Q} =^G_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \otimes \mathscr{Q} =^G_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$
    \item $\mathscr{Q} \overset{\epsilon}{\approx}^G_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \otimes \mathscr{Q} \overset{\epsilon}{\approx}^G_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$
    \item $\mathscr{Q} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \otimes \mathscr{Q} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}'} \mathscr{P} \otimes \mathscr{Q}'$
  \end{enumerate}

  \txbf{Proof:} We start by using Theorem~\ref{thm:concurrent_breakdown}, giving us:
  $$
  \tx{Inst}^G_{C'}(\mathscr{P} \otimes \mathscr{Q})
  =
  \begin{pmatrix}
    \tx{Inst}_{C'}(\mathscr{P})\cr
    \otimes\cr
    \tx{Inst}_C(\mathscr{Q})\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  =
  \begin{pmatrix}
    \tx{Inst}_{C'}(\mathscr{P})\cr
    \otimes\cr
    1(\tx{Out}(\tx{Inst}_C(\mathscr{Q})))\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  \tx{Inst}^G_C(\mathscr{Q})
  $$
  We can then immediately derive parts 1 and 2.

  For part 3, we apply the hypothesis to the last part of the above relation, to get:
  $$
  \tx{Inst}^G_{C'} \overset{\epsilon}{\approx}
  \begin{pmatrix}
    \tx{Inst}_{C'}(\mathscr{P})\cr
    \otimes\cr
    1(\tx{Out}(\tx{Inst}_C(\mathscr{Q})))\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  \tx{SimInst}^G_{S, C}(\mathscr{Q})
  $$
  Then, we unroll $\tx{SimInst}^G_{S, C}(\mathscr{Q})$, to get:
  $$
  \begin{pmatrix}
    \tx{Inst}_{C'}(\mathscr{P})\cr
    \otimes\cr
    1(\tx{Out}(\tx{Inst}_C(\mathscr{Q})))\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \begin{pmatrix}
      S\cr
      \otimes\cr
      1(\ldots)\cr
    \end{pmatrix}
    \circ \tx{Inst}_C(\mathscr{Q})\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  $$
  Then, we apply interchange to get:
  $$
  \begin{pmatrix}
    \begin{pmatrix}
      1(\ldots)\cr
      \otimes\cr
      S\cr
      \otimes\cr
      1(\ldots)\cr
    \end{pmatrix}
    \circ
    \begin{pmatrix}
    \tx{Inst}_{C'}(\mathscr{P})\cr
    \otimes\cr
    \tx{Inst}_C(\mathscr{Q})\cr
    \end{pmatrix}\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  $$
  But this is just $\tx{SimInst}^G_{S', C'}(\mathscr{P} \otimes \mathscr{Q})$,
  for some simulator $S'$,
  applying concurrent breakdown in reverse.

  $\blacksquare$
\end{theorem}

\begin{theorem}[Global Horizontal Composition Theorem]
  For any protocols $\mathscr{P}, \mathscr{Q}$ closed relative to $G$, with $\mathscr{P} \lhd \mathscr{Q}$
  well defined, and for any compatible corruption classes $\mathscr{C}, \mathscr{C'}$, we have:
  \begin{enumerate}
    \item $\mathscr{Q} =^G_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \lhd \mathscr{Q} =^G_{\mathscr{C}'} \mathscr{P} \lhd \mathscr{Q}'$
    \item $\mathscr{Q} \overset{\epsilon}{\approx}^G_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \lhd \mathscr{Q} \overset{\epsilon}{\approx}^G_{\mathscr{C}'} \mathscr{P} \lhd \mathscr{Q}'$
  \end{enumerate}

  Furthermore, if $\mathscr{C}'$ is \emph{strictly} compatible with $\mathscr{C}$,
  we have:
  \begin{enumerate}
    \setcounter{enumi}{2}
    \item $\mathscr{Q} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}} \mathscr{Q}' \implies \mathscr{P} \lhd \mathscr{Q} \overset{\epsilon}{\leadsto}^G_{\mathscr{C}'} \mathscr{P} \lhd \mathscr{Q}'$
  \end{enumerate}

  \txbf{Proof:} This proof is similar to that of Theorem~\ref{thm:horizontal_composition_theorem}.
  By compatibility, for any $C' \in \mathscr{C}'$, we have a compatible $C \in \mathscr{C}$.

  A crude summary of the horizontal breakdown theorem is that:
  $$
  \tx{Inst}_{C'}(\mathscr{P} \lhd \mathscr{Q})
  = \tx{Stuff} \circ \begin{pmatrix}
    \tx{Inst}_C(\mathscr{Q})\cr
    \otimes\cr
    1(\tx{In}(\mathscr{P}.F))
  \end{pmatrix}
  $$
  Using the fact that being closed relative to $G$ means $\tx{In}(\mathscr{P}.F) \subseteq \tx{Out}(G)$,
  we get:
  $$
  \tx{Inst}^G_{C'}(\mathscr{P} \lhd \mathscr{Q}) =
  \begin{pmatrix}
    \tx{Stuff}\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ \tx{Inst}^G_C(\mathscr{Q})
  $$
  Part 1 and 2 both follow immediately from this decomposition.

  For part 3, we dig a bit deeper into the proof of Theorem~\ref{thm:horizontal_composition_theorem}.
  In that proof, it was actually shown that:
  $$
  \tx{Stuff} \circ \tx{SimInst}_{S, C}(\mathscr{Q}') = \tx{SimInst}_{S', C'}(\mathscr{P} \lhd \mathscr{Q}')
  $$
  for some appropriate simulator $S'$.

  We can start to apply this, first by using our hypothesis:
  $$
  \tx{Inst}^G_{C'}(\mathscr{P} \lhd \mathscr{Q}) =
  \begin{pmatrix}
    \tx{Stuff}\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ \tx{Inst}^G_C(\mathscr{Q})
  \overset{\epsilon}{\approx}
  \begin{pmatrix}
    \tx{Stuff}\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ \tx{SimInst}^G_C(\mathscr{Q}')
  $$
  Next, we unroll the right side, to get:
  $$
  \begin{pmatrix}
    \tx{Stuff}\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{SimInst}_{S, C}(\mathscr{Q}')\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  G
  $$
  Then, apply interchange, to get:
  $$
  \begin{pmatrix}
    \tx{Stuff} \circ \tx{SimInst}_{S, C}(\mathscr{Q}')\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  G
  $$
  And finally, apply the fact we dug up above, to get:
  $$
  \begin{pmatrix}
    \tx{SimInst}_{S', C'}(\mathscr{P} \lhd \mathscr{Q})\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ
  G
  $$
  which is none other than $\tx{SimInst}^G_{S', C'}(\mathscr{P} \lhd \mathscr{Q})$.

  $\blacksquare$
\end{theorem}

So, the three big theorems we proved in the standalone context
also hold in the global context.
We could have saved some repetition by just doing everything in the global
context, but since we expect most proofs to be done standalone,
we felt that it was clearer to present that in more detail,
and then present the global generalizations more rapidly.

\subsection{Hopping Ideal Functionalities}

One difference between the framework we've developed and other
frameworks is that we always make statements about protocols.
Protocols are equal to each other, or simulate one another, etc.
In UC security, statements are usually between protocols and ideal functionalities.
One says that a protocol is simulated by a \emph{functionality},
and not another protocol.

Sometimes we want to be able to make this kind of statement as well,
and the following lemma can help us with that.

\begin{lemma}[Deidealization Lemma]
  Given a closed protocol $\mathscr{P}$ with an ideal functionality $F \otimes G$,
  there exists protocols $\mathscr{P}'$ and $\mathscr{G}$
  such that:
  $$
  \mathscr{P} \equiv \mathscr{P}' \lhd \mathscr{G}
  $$
  and $\mathscr{P}'$ has ideal functionality $F$.


  \txbf{Proof:} The players of $\mathscr{P}'$ are those of $\mathscr{P}$,
  except that each $P_i$'s call to a function $g \in \tx{Out}(G)$ is replaced with
  a renamed function $g_i$.
  $\mathscr{G}$ will have one player for each player in $\mathscr{P}'$.
  Each player $\mathscr{G}.P_i$ exports a function $g_i$ for each input
  $g_i$ of $\mathscr{P}'.P_i$, which immediately calls $g \in \tx{Out}(G)$,
  and returns the result.
  The leakage of $\mathscr{G}$ will simply be $\mathscr{P}.\tx{Leakage} \cap \tx{Out}(G)$.
  From this definition, it's clear that $\mathscr{P}$ is literally equal
  to $\mathscr{P}' \lhd \mathscr{G}$, as when the players in the latter
  are formed, the calls to the intermediate $g_i$ disappear,
  with each player calling $g \in \tx{Out}(G)$ directly

  $\blacksquare$
\end{lemma}

The idea is that if we're using some ideal functionality inside
of a protocol, we can actually write this as using
a \emph{sub-protocol}, where that sub-protocol is the one using
the ideal functionality.
This sub-protocol will be a kind of ``dummy protocol'',
which just immediately forwards inputs to the functionality.
This allows us to capture the kind of ``a protocol is simulated by functionality''
statement that one might want to make.
We would prove that a protocol simulates the \emph{dummy protocol}
associated with a given functionality.
Then, whenever that functionality is used inside of a protocol,
we can appeal to the deidealization lemma to argue that we can
replace the functionality with the concrete protocol.

An example might help with this.
Let's say we have a functionality $G$.
It's dummy protocol is, say, $\mathscr{G}$.
We might succeed in proving that
$\mathscr{Q} \leadsto \mathscr{G}$---ignoring corruption classes and the epsilon---
for a concrete protocol $\mathscr{Q}$.
Then, if we have a protocol $\mathscr{P} \circ G$,
by deidealization, we can write this as:
$\mathscr{P}' \lhd \mathscr{G}$, and then we use the fact that composition
respects simulation to conclude that
$$
\mathscr{P}' \lhd \mathscr{Q} \leadsto 
\mathscr{P}' \lhd \mathscr{G} = \mathscr{P} \circ G
$$
allowing us to replace a functionality with a concrete protocol.

Another similar idea allows us to turn global instantiation
into normal instantiation, by just embedding in the global functionality.

\begin{lemma}[Embedding Lemma]
  Given a protocol $\mathscr{P}$ closed relative to a game $G$,
  there exists a protocol $\tx{Embed}_G(\mathscr{P})$ such that for any
  corruption model $C$, we have:
  $$
  \tx{Inst}^G_C(\mathscr{P}) = \tx{Inst}_C(\tx{Embed}_G(\mathscr{P}))
  $$

  \txbf{Proof:}
  This one is quite simple. $\tx{Embed}_G(\mathscr{P})$ has the same players
  as $\mathscr{P}$, with the ideal functionality becoming:
  $$
  \begin{pmatrix}
    \mathscr{P}.F\cr
    \otimes\cr
    1(\tx{Out}(G))
  \end{pmatrix}
  \circ G
  $$
  and the leakage being $\mathscr{P}.\tx{Leakage} \cup \tx{Out}(G)$.
  The two instantiations will then clearly be equal under any corruption model.

  $\blacksquare$
\end{lemma}

The utility here is that we can prove a bunch of things in the
global model,
and then choose to actually instantiate the functionality
with a local version of it at some concrete point.
We might even then appeal to deidealization to replace the functionality
with a real protocol.
For example, some protocols proven secure in the global random oracle
model could be composed together,
and then the global random oracle could be replaced
by a local one, shared by all the protocols,
and then we could even replace this local random oracle with a
protocol to actually sample randomness.

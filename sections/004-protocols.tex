\section{Protocols and Composition}

\begin{definition}[Open Protocols]
An \emph{open protocol} $\mathcal{P}$ consists of:
\begin{itemize}
\item Systems $P_1, \ldots, P_n$, called \emph{players}
\item A package $F$, called the \emph{ideal functionality}
\end{itemize}

Furthermore, we also impose requirements on the channels and functions
these elements use.

First, we require that the player systems are jointly closed,
with no extra channels that aren't connected to other players:
$$
\bigcup_{i \in [n]} \text{OutChan}(P_i) = \bigcup_{i \in [n]} \text{InChan}(P_i)
$$

Second, we require that the functions the systems depend on are disjoint:
$$
\forall i, j \in [n].\quad \text{In}(P_i) \cap \text{In}(P_j) = \emptyset
$$

Third, we require that the functions the systems export on are disjoint:
$$
\forall i, j \in [n].\quad \text{Out}(P_i) \cap \text{Out}(P_j) = \emptyset
$$

We can also define a few convenient notations related to the interface of a base
protocol.

Let $\text{Out}_i(\mathcal{P}) := \text{Out}(P_i)$, and let $\text{In}_i(\mathcal{P}) := \text{In}(P_i) / \text{Out}(F)$.
We then define $\text{Out}(\mathcal{P}) := \bigcup_{i \in [n]} \text{Out}_i(\mathcal{P})$
and $\text{In}(\mathcal{P}) := \bigcup_{i \in [n]} \text{In}_i(\mathcal{P})$.

Finally, we define
$$
\begin{aligned}
&\text{IdealIn}(\mathcal{P}) := \text{In}(F)\cr
&\text{Leakage}(\mathcal{P}) := \text{Out}(F) / \left(\bigcup_{i \in [n]} \tx{In}(P_i)\right)
\end{aligned}
$$

$\square$
\end{definition}

\begin{definition}[Literal Equality]
Given two open protocols $\mathcal{P}$ and $\mathcal{Q}$, we say that
they are \emph{literally equal}, written as $\mathcal{P} \equiv \mathcal{Q}$
when:
\begin{itemize}
\item $\mathcal{P}.n = \mathcal{Q}.n$
\item There exists a permuation $\pi : [n] \leftrightarrow [n]$ such that
$
{\forall i \in [n].\enspace \mathcal{P}.P_i = \mathcal{Q}.P_{\pi(i)}}
$
\item $\mathcal{P}.F = \mathcal{P}.G$
\end{itemize}

$\square$
\end{definition}

\begin{definition}[Vertical Composition]
Given an open protocol $\mathcal{P}$ and a package $G$, satisfying
$\text{IdealIn}(\mathcal{P}) \subseteq \text{Out}(G)$,
we can define the open protocol $\mathcal{P} \circ G$.

$\mathcal{P} \circ G$ has the same players as $\mathcal{P}$,
but its ideal functionality $F$ becomes $F \circ G$.

$\square$
\end{definition}

\begin{claim}[Vertical Composition is Associative]
For any protocol $\mathcal{P}$, and packages $G, H$, such that their composition
is well defined, we have
$$
\mathcal{P} \circ (G \circ H) = (\mathcal{P} \circ G) \circ H
$$

\txbf{Proof:} This follows from the definition of vertical composition
and the associativity of $\circ$ for packages.
$\blacksquare$
\end{claim}

\begin{definition}[Horizontal Composition]
Given two open protocols $\mathcal{P}, \mathcal{Q}$,
we can define the open protocol $\mathcal{P} \lhd \mathcal{Q}$,
provided a few requirements hold.

First, we need: $\text{In}(\mathcal{P}) \subseteq \text{Out}(\mathcal{Q})$.
We also require that the functions exposed by a player in $\mathcal{Q}$
are used by \emph{exactly} one player in $\mathcal{P}$.
We express this as:
\[
  \forall i \in [\mathcal{Q}.n].\ \exists! j \in [\mathcal{P}.n].\quad \text{In}_j \cap \text{Out}_i \neq \emptyset
\]

Second, we require that the players share no channels between the two
protocols.
In other words $\text{Chan}(\mathcal{P}.P_i) \cap \text{Chan}(\mathcal{Q}.P_j) = \emptyset$, for all $P_i, P_j$.

Third, we require that the leakages of one game aren't use in the other:
$$
\begin{aligned}
&\tx{Leakage}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset\cr
&\tx{Leakage}(\mathcal{Q}) \cap \tx{In}(\mathcal{P}) = \emptyset
\end{aligned}
$$

Finally, we require that the ideal functionalities do not overlap, 
  in the sense that $\text{Out}(\mathcal{P}.F) \cap \text{Out}(\mathcal{Q}.F) = \emptyset$

Our first condition has an interesting consequence: every player $\mathcal{Q}.P_j$
has its functions used by exactly one player $\mathcal{P}.P_i$.
In that case, we say that $\mathcal{P}.P_i$ \emph{uses} $\mathcal{Q}.P_j$.

With this in hand, we can define $\mathcal{P} \lhd \mathcal{Q}$.

The players will consist of:
$$
  \mathcal{P}.P_i \circ \left( \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } \mathcal{Q}.P_j \right)
$$
And, because of our assumption, each player in $\mathcal{Q}$ appears
somewhere in this equation.

The ideal functionality is $\mathcal{P}.F \otimes \mathcal{Q}.F$.

We can also easily show that this definition is well defined, satisfying
the required properties of an open protocol.
Because of the definition of the players, we see that:
$$
  \bigcup_{i \in [(\mathcal{P} \lhd \mathcal{Q}).n]} \tx{OutChan}((\mathcal{P} \lhd \mathcal{Q}).{P_i})
  = \left(\bigcup_{i \in [\mathcal{P}.n]} \tx{OutChan}(\mathcal{P}.P_i)\right) \cup
  \left(\bigcup_{i \in [\mathcal{Q}.n]} \tx{OutChan}(\mathcal{Q}.P_i)\right)
$$
  since $\text{OutChan}(A \circ B) = \text{OutChan}(A \otimes B) = \text{OutChan}(A, B)$.
A similar reasoning applies to $\text{InChan}$, allowing us to conclude that:
$$
  \bigcup_{i \in [(\mathcal{P} \lhd \mathcal{Q}).n]} \tx{OutChan}((\mathcal{P} \lhd \mathcal{Q}).{P_i}) =
  \bigcup_{i \in [(\mathcal{P} \lhd \mathcal{Q}).n]} \tx{InChan}((\mathcal{P} \lhd \mathcal{Q}).{P_i})
$$
as required.

By definition, the dependencies $\text{In}$ of each player in $\mathcal{P} \lhd \mathcal{Q}$
are the union of several players in $\mathcal{Q}$, so disjointness property
continues to hold.

Finally, since each player is of the form $\mathcal{P}.P_i \circ \ldots$,
the condition on $\text{Out}_i$ is also satisfied in $\mathcal{P} \lhd \mathcal{Q}$,
since $\mathcal{P}$ does.

$\square$

\end{definition}

\begin{lemma}
Horizontal composition is associative, i.e.
${\mathcal{P} \lhd (\mathcal{Q} \lhd \mathcal{R}) \equiv (\mathcal{P} \lhd \mathcal{Q}) \lhd \mathcal{R}}$
for all open protocols $\mathcal{P}, \mathcal{Q}, \mathcal{R}$ where this expression is well defined.

$\txbf{Proof:}$
For the ideal functionalities, it's clear that by the associativity
of $\otimes$ for systems, the resulting functionality is the same
in both cases.

The trickier part of the proof is showing that the resulting players
are identical.

It's convenient to define a relation for the players in $\mathcal{R}$
that get used in $\mathcal{P}$ via the players in $\mathcal{Q}$.
To that end, we say that $\mathcal{P}.P_i$ \emph{uses} $\mathcal{R}.P_j$
if there exists $\mathcal{Q}.P_k$ such that $\mathcal{P}.P_i$ uses
$\mathcal{Q}.P_k$, and $\mathcal{Q}.P_k$ uses $\mathcal{R}.P_j$.

The players of $\mathcal{P} \lhd (\mathcal{Q} \lhd \mathcal{R})$ are of the form:
$$
  \mathcal{P}.P_i \circ
  \left( \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j \circ
  \left( \bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{Q}.P_j } \mathcal{R}.P_k
  \right)
  \right)
$$
While those in $(\mathcal{P} \lhd \mathcal{Q}) \mathcal{R}$ are of the form:
$$
  \left( \mathcal{P}.P_i \circ
  \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j
  \right)
  \circ
  \left(\bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{P}.P_i } \mathcal{R}.P_k
  \right)
$$
Now, we can apply the associativity of $\circ$ for systems, and also
group the $\mathcal{R}.P_k$ players based on which $\mathcal{Q}.P_j$ uses them:
$$
  \mathcal{P}.P_i \circ
  \left(
  \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j
  \right)
  \circ
  \left(
    \bigast_{\mathcal{Q}.P_j}
  \left(\bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{Q}.P_j } \mathcal{R}.P_k
  \right)
  \right)
$$
Now, the conditions are satisfied for applying the interchange lemma (Lemma~\ref{thm:interchange_system}),
giving us:
$$
  \mathcal{P}.P_i \circ
  \left( \bigast_{\mathcal{Q}.P_j \text{ used by } \mathcal{P}.P_i } 
  \mathcal{Q}.P_j \circ
  \left( \bigast_{\mathcal{R}.P_k \text{ used by } \mathcal{Q}.P_j } \mathcal{R}.P_k
  \right)
  \right)
$$
Which is non other than the players in $\mathcal{P} \lhd (\mathcal{Q} \lhd \mathcal{R})$.

$\blacksquare$
\end{lemma}

\begin{definition}[Concurrent Composition]
Given two open open protocols $\mathcal{P}, \mathcal{Q}$,
we can define their concurrent composition---or tensor product---
$\mathcal{P} \otimes \mathcal{Q}$, provided a few requirements hold.
We require that:
\begin{enumerate}
\item $\tx{In}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset$.
\item $\tx{Out}(\mathcal{P}) \cap \tx{Out}(\mathcal{Q}) = \emptyset$.
\item $\tx{Out}(\mathcal{P}.F) \cap \tx{Out}(\mathcal{Q}.F) = \emptyset$ \emph{or} $\mathcal{P}.F = \mathcal{Q}.F$.
\item $\tx{Leakage}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset = \tx{Leakage}(\mathcal{Q}) \cap \tx{In}(\mathcal{P})$
\end{enumerate}

The players of $\mathcal{P} \otimes \mathcal{Q}$ consist of all the players
in $\mathcal{P}$ and $\mathcal{Q}$.
The ideal functionality is $\mathcal{P}.F \otimes \mathcal{Q}.F$, 
unless $\mathcal{P}.F = \mathcal{Q}.F$, in which case the ideal functionality
is simply $\mathcal{P}.F$.
This use of $\otimes$ is well defined by assumption.

The resulting protocol is also clearly well defined.

The jointly closed property holds because we've simply taken the union
of both player sets.

Since $\tx{In}(\mathcal{P}) \cap \tx{In}(\mathcal{Q}) = \emptyset$,
it also holds that for every $P_i, P_j$ in $\mathcal{P} \otimes \mathcal{Q}$,
we have $\tx{In}(P_i) \cap \tx{In}(P_j) = \emptyset$,
since each player comes from either $\mathcal{P}$ or $\mathcal{Q}$.
      
Finally, $\tx{Out}(\mathcal{P}) \cap \tx{Out}(\mathcal{Q}) = \emptyset$,
we have that $\tx{Out}(P_i) \cap \tx{Out}(P_j) = \emptyset$,
by the same reasoning.
    
$\square$
\end{definition}

\todo{The reason why we allow for $F = G$ is so that you can have like the same $1$}

\begin{lemma}
Concurrent composition is associative and commutative.
I.e. $\mathcal{P} \otimes (\mathcal{Q} \otimes \mathcal{R}) \equiv (\mathcal{P} \otimes \mathcal{Q}) \otimes \mathcal{R}$,
and $\mathcal{P} \otimes \mathcal{Q} \equiv \mathcal{Q} \otimes \mathcal{P}$ for
all open protocols $\mathcal{P}, \mathcal{Q}, \mathcal{R}$ where these expressions
are well defined.

\txbf{Proof:}

By the definition of $\equiv$, all that matter is the \emph{set} of players,
and not their order.
Because $\cup$ is associative, and so is $\otimes$ for systems,
we conclude that concurrent composition is associative as well,
since the resulting set of players and ideal functionality are the same
in both cases.

Similarly, since $\cup$ and $\otimes$ (for systems) are commutative,
we conclude that concurrenty composition is commutative.

$\blacksquare$
\end{lemma}

\subsection{Corruption and Simulation}

\begin{definition}[``Honest'' Corruption]
Given a system $P$,
we define the ``honest'' corruption of $P$
$$
\tx{Corrupt}_H(P) := P
$$

$\square$
\end{definition}

\begin{definition}[Semi-Honest Corruption]
Given a system $P$, we can define
the semi-honest corruption $\tx{Corrupt}_{\tx{SH}}(P)$.

This is a transformation of
of $P$, providing access to its ``view''.
More formally, $\tx{Corrupt}_{\tx{SH}}(P)$ is a system which works the same
as $P$, but with an additional public variable $\tx{log}$,
initialized with ${\tx{log} \gets \tx{FifoQueue.New()}}$.
Additionally, $\tx{Corrupt}_{\tx{SH}}(P)$ modifies $P$ by pushing events to this
log at different points in time.
These events are:
\begin{itemize}
\item $(\texttt{rand}, x)$ when a random value $x$ is sampled.
\item $(\texttt{call}, F, (x_1, \ldots, x_n))$ when a function call $F(x_1, \ldots, x_n)$ happens.
\item $(\texttt{ret}, F, y)$ when the function $F$ returns a value $y$.
\item $(\texttt{send}, A, m)$ when a value $m$ is sent on channel $A$.
\item $(\texttt{recv}, B, m)$ when a value $m$ is received on channel $B$.
\end{itemize}

$\square$
\end{definition}

\begin{definition}[Malicious Corruption]
Given a system $P$ with:
$$
\begin{aligned}
  &\tx{In}(P) = \{F_1, \ldots, F_n\}\cr
  &\tx{OutChan}(P) = \{A_1, \ldots, A_m\}\cr
  &\tx{InChan}(P) = \{B_1, \ldots, B_l\}\cr
\end{aligned}
$$
we define the malicious corruption $\tx{Corrupt}_M(P)$ as the following game:
\package{$\tx{Corrupt}_M(P)$}{
&\underline{\tx{Call}_{F_i}((x_1, \ldots, x_n))\tx{:}}\cr
\pind{1} \preturn{F_i(x_1, \ldots, x_n)}\cr
\cr
&\underline{\tx{Send}_{A_i}(m)\tx{:}}\cr
\pind{1} \psend{m}{A_i}\cr
\cr
&\underline{\tx{Recv}_{B_i}()\tx{:}}\cr
\pind{1} \preturn{\precv{m}{B_i}}\cr
}

In other words, malicious corruption provides access to the functions
and channels used by $P$, but no more than that.

$\square$
\end{definition}

\begin{lemma}[Simulating Corruptions]
  We can simulate corruptions using strong forms of corruption.
  In particular, there exists systems $S_{\tx{SH}}$ and $S_{\tx{H}}$ such that
  for all systems $P$, we have:
  \[
    \begin{aligned}
      &\tx{Corrupt}_{\tx{SH}}(P) = S_{\tx{SH}} \circ \tx{Corrupt}_M(P)\cr
      &\tx{Corrupt}_{\tx{H}}(P) = S_{\tx{H}} \circ \tx{Corrupt}_{\tx{SH}}(P)
    \end{aligned}
  \]

\txbf{Proof:}
For the simulation of honest corruption, we can simply ignore
  the additional log variable, and set $S_{\tx{H}} := 1(\tx{Out}(P))$.

For semi-honest corruption, $S_{\tx{SH}}$ is formed by transforming
$\tx{Corrupt}_{\tx{SH}}(P)$, replacing:
\begin{itemize}
  \item every function call with $\tx{Call}_{F_i}(\ldots)$,
  \item every sending of a message $m$ on $A$ with $\tx{Send}_A(m)$,
  \item every reception of a message on $B$ with $\tx{Recv}_B()$.
\end{itemize}
The result is clearly a perfect emulation of semi-honest corruption
using malicious corruption.

$\blacksquare$
\end{lemma}

Sometimes, it's useful to be able to talk about corruptions in general,
in which case we write $\text{Corrupt}_\kappa(P)$,
for $\kappa \in \{\tx{H}, \tx{SH}, \tx{M}\}$.

\begin{definition}[Corruption Models]
Given a protocol $\mathcal{P}$ with players $P_1, \ldots, P_n$, a \emph{corruption model} $C$
is a function $C : [\mathcal{P}.n] \to \{\tx{H}, \tx{SH}, \tx{M}\}$.
This provides a corruption $C_i$ associated with each player $P_i$.
We can then define $\text{Corrupt}_C(P_i) := \text{Corrupt}_{C_i}(P_i)$.

Corruption models have a natural partial order associated with them. 
We have:
$$
\tx{H} < \tx{SH} < \tx{M}
$$
  and then we say that $C \geq C'$ if $\forall i \in [n]. \quad C_i \geq C'_i$.

A \emph{class of corruptions} $\mathcal{C}$ is simply a set of corruption models.

$\square$
\end{definition}

Some common classes are:
\begin{itemize}
  \item The class of malicious corruptions, where all but one player is malicious.
  \item The class of malicious corruptions, where all but one player is semi-honest.
\end{itemize}

\begin{definition}[Instantiation]
  Given a protocol $\mathcal{P}$ with $\text{In}(\mathcal{P}) = \emptyset$ and a corruption model $C$, we can
  define an \emph{instantiation} $\tx{Inst}_C(\mathcal{P})$, which
  is a system defining the semantics of the protocol.

  First, we need to define a transformation of systems to use
  a \emph{router} $\mathcal{R}$, which will be a special system
  allowing an adversary to control the order of delivery of messages.

  Let $\{A_1, \ldots, A_n\} = \tx{Chan}(P_1, \ldots, P_n)$.
  We then define $\mathcal{R}$ as the syten:
\package{$\mathcal{R}$}{
&\underline{\tx{Deliver}_{A_i}()\tx{:}}\cr
\pind{1} \precv{m}{\langle A_i, \mathcal{R} \rangle}\cr
\pind{1} \psend{m}{\langle \mathcal{R}, A_i \rangle}\cr
}

  Next, we define a transformation $\tx{Routed}(S)$ of a system,
  which makes communication pass via the router:
  \begin{itemize}
    \item Whenever $S$ sends $m$ via $A$, $\tx{Routed}(S)$ sends $m$ via $\langle A , \mathcal{R} \rangle$.
    \item Whenever $S$ receives $m$ via $B$, $\tx{Routed}(S)$ recieves $m$ via $\langle \mathcal{R}, B \rangle$.
  \end{itemize}

With this in hand, we define:
$$
\tx{Inst}_C(\mathcal{P}) := \left(\mathcal{R} * \bigast_{i \in [n]} \tx{Routed}(\tx{Corrupt}_C(P_i))\right) \circ F
$$


$\square$
\end{definition}

\begin{definition}[Associated Corruption Classes]
\label{def:assoccc}
Given two protocols $\mathcal{P}, \mathcal{Q}$ where $\otimes$ is well
defined, a corruption class $\mathcal{C}$ for $\mathcal{Q}$ has a natural
corruption class $\mathcal{C}'$ for $\mathcal{P} \otimes \mathcal{Q}$.

For each model $C \in \mathcal{C}$, the resulting $\mathcal{C}'$ will
contain a model for each possible honest corruption of the players
in $P$ with efficient agents $A_1, \ldots$.
In other words, the corruptions in this class will be those of $\mathcal{C}$,
with $\mathcal{P}$ always behaving honestly.


We can also do the same for $\mathcal{P} \circ \mathcal{Q}$,
but the corruption class $\mathcal{C}'$ is a bit trickier.
We say that a corruption model $C$ for $\mathcal{P}$ is compatible with
a corruption model $C'$ for $\mathcal{Q}$ if for every
$\mathcal{Q}.P_j$ used by $\mathcal{P}.P_i$, the corruption
level of $\mathcal{Q}.P_j$ in $\mathcal{C}'$ is $\geq$ the corruption level of $\mathcal{P}.P_i$
in $\mathcal{C}$.
A corruption model $C$ for $\mathcal{P}$ is compatible
with a \emph{class} of corruptions $\mathcal{C}$, if
there exists a compatible model $C'$ in $\mathcal{C}$.

With this in hand, the corruption class $\mathcal{C}'$ for $\mathcal{P} \circ \mathcal{Q}$
is the largest (closed) corruption class $\mathcal{C}'$ for $\mathcal{P}$ such
that each $C \in \mathcal{C}'$ is compatible with $\mathcal{C}$.
Because of the definition of $\circ$, a corruption model
for $\mathcal{P}$ naturally yields a model for $\mathcal{P} \circ \mathcal{Q}$,
so this is well defined.


$\square$
\end{definition}

\subsection{Equality and Simulation}

\begin{definition}[Semantic Equality]
  We say that two protocols $\mathcal{P}$ and $\mathcal{Q}$
  are equal under a class of corruptions $\mathcal{C}$,
  written as $\mathcal{P} =_{\mathcal{C}} \mathcal{Q}$, when we have:
  $$
  \forall C \in \mathcal{C}.\quad \tx{Inst}_C(\mathcal{P}) = \tx{Inst}_C(\mathcal{Q})
  $$
  as systems.

  $\square$

\end{definition}

\begin{lemma}[Literal $\implies$ Semantic]
For any corruption class $\mathcal{C}$
$$
\mathcal{P} \equiv \mathcal{Q} \implies \mathcal{P} =_\mathcal{C} \mathcal{Q}.
$$

\txbf{Proof:} This follows directly from the definition of $\tx{Inst}_C(\ldots)$,
which will yield an equal system if its components are equal. $\blacksquare$
\end{lemma}
\begin{lemma}[Tensoring respects semantic equality]
For any corruption class $\mathcal{C}$, if $\mathcal{Q} =_\mathcal{C} \mathcal{Q}'$,
then $\mathcal{P} \otimes \mathcal{Q} =_\mathcal{C'} \mathcal{P} \otimes \mathcal{Q}'$,
with $\mathcal{C}'$ as per Definition~\ref{def:assoccc}.

\txbf{Proof:} If we unroll $\text{Inst}_{C'}(\mathcal{P} \otimes \mathcal{Q})$, we get:
$$
\begin{pmatrix}
\mathcal{R}\cr
*\cr
\left(\bigast_{i \in [\mathcal{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{P}.P_i))\right)\cr
*\cr
\left(\bigast_{i \in [\mathcal{Q}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{Q}.P_i))\right)
\end{pmatrix}
\circ
\begin{pmatrix}
\mathcal{P}.F\cr
\otimes\cr
\mathcal{Q}.F\cr
\end{pmatrix}
$$

We can apply a few observations here:
\begin{enumerate}
  \item $C'$ is such that $\mathcal{P}.P_i$ is always honest, and $\mathcal{Q}.P_i$ follows
  some corruption model $C \in \mathcal{C}$, by the definition of $\mathcal{C}'$.
  \item $\mathcal{R}$ can be written as $\mathcal{R}_\mathcal{P} \otimes \mathcal{R}_\mathcal{Q}$,
  with one system using channels in $\mathcal{P}$, and the other using channels in $\mathcal{Q}$.
  \item Since protocols are closed, we can use $\otimes$ between the players in $\mathcal{P}$ and $\mathcal{Q}$,
  since they never send messages to each other.
\end{enumerate}
This results in the following:
$$
\begin{pmatrix}
\mathcal{R}_{\mathcal{P}} * \left(\bigast_{i \in [\mathcal{P}.n]} \tx{Routed}(\tx{Corrupt}_{C'}(\mathcal{P}.P_i))\right)\cr
\otimes\cr
\mathcal{R}_{\mathcal{Q}} * \left(\bigast_{i \in [\mathcal{Q}.n]} \tx{Routed}(\tx{Corrupt}_{C}(\mathcal{Q}.P_i))\right)
\end{pmatrix}
\circ
\begin{pmatrix}
\mathcal{P}.F\cr
\otimes\cr
\mathcal{Q}.F\cr
\end{pmatrix}
$$
From here, we apply Lemma~\ref{thm:interchange_system} (interchange), to get:
$$
\begin{matrix}
\tx{Inst}_{C'}(\mathcal{P})\cr
\otimes\cr
\tx{Inst}_{C}(\mathcal{Q})\cr
\end{matrix}
$$
And since $Q =_\mathcal{C} Q'$, this is equal to:
$$
\begin{matrix}
\tx{Inst}_{C'}(\mathcal{P})\cr
\otimes\cr
\tx{Inst}_{C}(\mathcal{Q'})\cr
\end{matrix}
$$
and we can reverse the logic above to see that this is equal
to $\tx{Inst}_{C'}(\mathcal{P} \otimes \mathcal{Q}')$.

$\blacksquare$
\end{lemma}

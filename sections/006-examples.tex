\section{Examples}

\subsection{Constructing Private Channels}

In this section, we consider the problem of constructing a \emph{private}
channel from a \emph{public} channel.
A public channel leaks all messages sent over it to an adversary,
whereas a private channel leaks a minimal amount of information:
in our case, essentially just the length of messages sent over the channel.

We'll be constructing a two-party private channel from a public channel
using an encryption scheme, and will also show that this construction is secure,
even if one of the two parties using the channel is corrupted.

Let's start with the ideal functionality representing a public channel,
as Game~\ref{game:pubchan}.

A few clarifications on the notation in this game:
\begin{itemize}
    \item For $i \in \{1, 2\}$, we let $\noti$ denote either $2$ or $1$, respectively.
    \item There are two versions of $\tx{Send}_i$ and $\tx{Recv}_i$, for $i \in \{1, 2\}$.
    \item The $\tx{pop}$ function on queues is asynchronous, meaning that we wait until the queue is not empty
    to remove the oldest element from it.
    \item The queues are public in an \emph{immutable} fashion: they can be read but not modified outside the package.
\end{itemize}

\begin{game}{game:pubchan}{Public Channel Functionality}
\package{$F[\tx{PubChan}]$}{
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i\to \noti}$}{m}\cr
        \pind{1}m_{i\to \noti}.\tx{push}(m)\cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i\to \noti}$}{}\cr
        &\preturn{\await{m_{i\to \noti}.\tx{pop}()}}
    \end{aligned}
}
\end{game}

The idea behind this functionality is that each party can send messages to,
or receive messages from the other party.
However, at any point, the currently stored messages are readable by
the adversary.
Note that this assignment of which functions
are usable by which entities is not defined by the functionality \emph{itself},
but rather merely suggested by its syntax, and enforced only by how
protocols will eventually use the functionality.

Next, we look at a functionality for \emph{private} channels,
captured by Game~\ref{game:privchan}.

\begin{game}{game:privchan}{Private Channel Functionality}
\package{$F[\tx{PrivChan}]$}{
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } l_{1\to2}, l_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i\to \noti}$}{m}\cr
        \pind{1}m_{i\to \noti}.\tx{push}(m)\cr
        \pind{1}l_{i\to \noti}.\tx{push}((\txt{push}, |m|))\cr
        \cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i\to \noti}$}{}\cr
        \pind{1} \set{m}{\await{m_{i\to \noti}.\tx{pop}()}}\cr
        \pind{1}l_{i\to \noti}.\tx{push}(\txt{pop})\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\end{game}

The crucial difference is the nature of the leakage.
Now, rather than being able to see the current state of either message queue,
including the messages themselves, now the adversary can only
see a historical log for each queue, describing only the \emph{length}
of the messages inserted into the queue.
The reason for having a historical log, rather than just a snapshot
of the lengths of the current messages,
is to make the simulator's job easier
in the eventual proof of security.

Now, we need to define the protocols.
One protocol will use the private channel to send messages,
and the other will try and implement the same behavior,
but using only the public channel, aided by an encryption scheme.

Let's start with the simpler private channel protocol, which we'll
call, for lack of imagination, $\mathcal{Q}$,
and defined via Protocol~\ref{prot:privchan}

\begin{protocol}{prot:privchan}{Private Channel Protocol}
    $\mathcal{Q}$ is characterized by:
    \begin{itemize}
        \item $\tx{Leakage} := \{l_{1\to 2}, l_{2\to1}\}$,
        \item $F := \tx{PrivChan}$,
        \item And two players defined via the following system (for $i \in \{1, 2\}$):
\package{$P_i$}{
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \tx{Send}_{i \to \noti}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \preturn{\await \tx{Recv}_{\noti \to i}()}\cr
    \end{aligned}
}
    \end{itemize}

\end{protocol}

This protocol basically just provides each player access with their corresponding
functions in the functionality, and leaks the parts of the functionality
that the adversary should have access to, as expected.

Next, we need to define a protocol providing an encrypted channel.
Thanks to a brilliant stroke of creativity, we'll call this one $\mathcal{P}$.
The basic idea is that $\mathcal{P}$ will encrypt messages before sending
them over the public channel.
We'll be using public-key encryption, as defined in \todo{todo}.
For the sake of simplicity, we'll be relying on an additional functionality,
$\tx{Keys}$, which will be used to setup each party's key pair, and allow
each party to agree on the other's public key.

This functionality is defined in Game~\ref{game:keys}.
The basic idea is that a key pair is generated for each party,
and that party can see their secret key, along with the public key for the other party.

\begin{game}{game:keys}{Keys Functionality}
\package{Keys}{
&\draw{(\tx{sk}_1, \tx{pk}_1)}{\tx{Gen}()}\cr
&\draw{(\tx{sk}_2, \tx{pk}_2)}{\tx{Gen}()}\cr
\cr
&\pfn{$\tx{Keys}_i$}{}\cr
\pind{1} \preturn{(\tx{sk}_i, \tx{pk}_{\noti})}\cr
}
\end{game}

With this in hand, we can define $\mathcal{P}$ itself, in Protocol~\ref{prot:encchan}.

\begin{protocol}{prot:encchan}{Encrypted Channel Protocol}
    $\mathcal{P}$ is characterized by:
    \begin{itemize}
        \item $\tx{Leakage} := \{m_{1\to 2}, m_{2\to1}\}$,
        \item $F := \tx{Keys} \otimes \tx{PrivChan}$,
        \item and two players defined via the following system (for $i \in \{1, 2\}$):
\package{$P_i$}{
    &(\tx{sk}_i, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \tx{Send}_{i \to \noti}(\tx{Enc}(\tx{pk}_{\noti}, m))\cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{Recv}_{\noti \to i}()}\cr
        \pind{1} \preturn{\tx{Dec}(\tx{sk}_i, c)}\cr
    \end{aligned}
}
    \end{itemize}

\end{protocol}

Each player will encrypt their message for the other player before sending it,
and then decrypt it using their secret key after receiving it.

At this point we can state and prove the crux of this example:

\begin{claim}
Let $\mathcal{C}$ be the class of corruptions where up to 1 of 2 parties
is either maliciously corrupt or semi-honestly corrupt.
Then we have:
$$
\mathcal{P} \overset{2 \cdot \tx{IND}}{\leadsto}_{\mathcal{C}} \mathcal{Q}
$$

\txbf{Proof:} We consider the cases where all the parties are honest
and some of the parties are corrupted separately.
Furthermore, we only need to consider malicious corruption,
since the parties in $\mathcal{Q}$ just directly call functions from
the ideal functionality, and so we can simulate malicious corruption
from semi-honest corruption, and can thus apply part 3
of Theorem~\ref{thm:mal_complete}.

\txbf{Honest Case:} Let $\tx{H}$ be a corruption model where both parties are honest.
We prove that $\mathcal{P} \overset{2 \cdot \tx{IND}}{\leadsto}_{\{\tx{H}\}} \mathcal{Q}$.

\txbf{Malicious Case:}
Without loss of generality, we can consider the case where $P_1$ is malicious.
This is because the difference between the parties is just a matter of renaming
variables.
Let $\tx{M}$ denote this corruption model.
We prove that $\mathcal{P} \overset{0}{\leadsto}_{\{\tx{M}\}} \mathcal{Q}$,
which naturally implies the slightly higher upper bound of $2 \cdot \tx{IND}$.

Having now proved the upper bound for all the corruption models in $\mathcal{C}$,
we conclude that our claim holds.

$\blacksquare$
\end{claim}
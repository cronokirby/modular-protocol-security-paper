\section{Examples}

In this section, we provide a couple example proofs in the framework,
to illustrate how it works, and some of the advantages it provides.
The two examples we provide are that of constructing a private
channel from one that leaks all messages sent on it,
and that of sampling an unbiased random value using
the ubiquitous paradigm of ``commit reveal''.

\subsection{Constructing Private Channels}

In this subsection, we consider the problem of constructing a \emph{private}
channel from a \emph{public} channel.
A public channel leaks all messages sent over it to an adversary,
whereas a private channel leaks a minimal amount of information:
in our case, essentially just the length of messages sent over the channel.
This example was also used in \cite{cramer2015secure}.

We'll be constructing a two-party private channel from a public channel
using an encryption scheme, and will also show that this construction is secure,
even if one of the two parties using the channel is corrupted.

Let's start with the ideal functionality representing a public channel,
as Game~\ref{game:pubchan}.

A few clarifications on the notation in this game:
\begin{itemize}
    \item For $i \in \{1, 2\}$, we let $\noti$ denote either $2$ or $1$, respectively.
    \item There are two versions of $\tx{Send}_i$ and $\tx{Recv}_i$, for $i \in \{1, 2\}$.
    \item The $\tx{pop}$ function on queues is asynchronous, meaning that we wait until the queue is not empty
    to remove the oldest element from it.
    \item The queues are public in an \emph{immutable} fashion: they can be read but not modified outside the package.
\end{itemize}

\begin{game}{game:pubchan}{Public Channel Functionality}
\package{$F[\tx{PubChan}]$}{
    &\txbf{view } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i\to \noti}$}{m}\cr
        \pind{1}m_{i\to \noti}.\tx{push}(m)\cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i\to \noti}$}{}\cr
        &\preturn{\await{m_{i\to \noti}.\tx{pop}()}}
    \end{aligned}
}
\end{game}

The idea behind this functionality is that each party can send messages to,
or receive messages from the other party.
However, at any point, the currently stored messages are readable by
the adversary.
Note that this assignment of which functions
are usable by which entities is not defined by the functionality \emph{itself},
but rather merely suggested by its syntax, and enforced only by how
protocols will eventually use the functionality.

Next, we look at a functionality for \emph{private} channels,
captured by Game~\ref{game:privchan}.

\begin{game}{game:privchan}{Private Channel Functionality}
\package{$F[\tx{PrivChan}]$}{
    &\txbf{view } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } l_{1\to2}, l_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i\to \noti}$}{m}\cr
        \pind{1}m_{i\to \noti}.\tx{push}(m)\cr
        \pind{1}l_{i\to \noti}.\tx{push}((\txt{push}, |m|))\cr
        \cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i\to \noti}$}{}\cr
        \pind{1} \set{m}{\await{m_{i\to \noti}.\tx{pop}()}}\cr
        \pind{1}l_{i\to \noti}.\tx{push}(\txt{pop})\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\end{game}

The crucial difference is the nature of the leakage.
Now, rather than being able to see the current state of either message queue,
including the messages themselves, now the adversary can only
see a historical log for each queue, describing only the \emph{length}
of the messages inserted into the queue.
The reason for having a historical log, rather than just a snapshot
of the lengths of the current messages,
is to make the simulator's job easier
in the eventual proof of security.
For technical reasons, it's simpler to allow the log to be mutated,
so that the simulator can ``remember'' which parts of the log they've
already seen, by popping elements from the queue.

Now, we need to define the protocols.
One protocol will use the private channel to send messages,
and the other will try and implement the same behavior,
but using only the public channel, aided by an encryption scheme.

Let's start with the simpler private channel protocol, which we'll
call $\mathscr{Q}$,
and defined via Protocol~\ref{prot:privchan}

\begin{protocol}{prot:privchan}{Private Channel Protocol}
    $\mathscr{Q}$ is characterized by:
    \begin{itemize}
        \item $\tx{Leakage} := \{l_{1\to 2}, l_{2\to1}\}$,
        \item $F := \tx{PrivChan}$,
        \item And two players defined via the following system (for $i \in \{1, 2\}$):
\package{$P_i$}{
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \tx{Send}_{i \to \noti}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \preturn{\await \tx{Recv}_{\noti \to i}()}\cr
    \end{aligned}
}
    \end{itemize}

\end{protocol}

This protocol basically just provides each player access with their corresponding
functions in the functionality, and leaks the parts of the functionality
that the adversary should have access to, as expected.

Next, we need to define a protocol providing an encrypted channel.
We'll call this one $\mathscr{P}$.
The basic idea is that $\mathscr{P}$ will encrypt messages before sending
them over the public channel.
We'll be using public-key encryption, as defined in Appendix~\ref{app:encryption}.
For the sake of simplicity, we'll be relying on an additional functionality,
$\tx{Keys}$, which will be used to setup each party's key pair, and allow
each party to agree on the other's public key.

This functionality is defined in Game~\ref{game:keys}.
The basic idea is that a key pair is generated for each party,
and that party can see their secret key, along with the public key for the other party.
Furthermore, we allow the adversary to see both public keys.

\begin{game}{game:keys}{Keys Functionality}
\package{Keys}{
&\draw{(\tx{sk}_1, \tx{pk}_1)}{\tx{Gen}()}\cr
&\draw{(\tx{sk}_2, \tx{pk}_2)}{\tx{Gen}()}\cr
\cr
&\pfn{$\tx{Keys}_i$}{}\cr
\pind{1} \preturn{(\tx{sk}_i, \tx{pk}_{\noti})}\cr
\cr
&\pfn{PKs}{}\cr
\pind{1} \preturn{(\tx{pk}_1, \tx{pk}_2)}\cr
}
\end{game}

With this in hand, we can define $\mathscr{P}$ itself, in Protocol~\ref{prot:encchan}.

\begin{protocol}{prot:encchan}{Encrypted Channel Protocol}
    $\mathscr{P}$ is characterized by:
    \begin{itemize}
        \item $\tx{Leakage} := \{m_{1\to 2}, m_{2\to1}, \tx{PKs}\}$,
        \item $F := \tx{Keys} \otimes \tx{PrivChan}$,
        \item and two players defined via the following system (for $i \in \{1, 2\}$):
\package{$P_i$}{
    &(\tx{sk}_i, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \tx{Send}_{i \to \noti}(\tx{Enc}(\tx{pk}_{\noti}, m))\cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{Recv}_{\noti \to i}()}\cr
        \pind{1} \preturn{\tx{Dec}(\tx{sk}_i, c)}\cr
    \end{aligned}
}
    \end{itemize}

\end{protocol}

Each player will encrypt their message for the other player before sending it,
and then decrypt it using their secret key after receiving it.

At this point we can state and prove the crux of this example:

\begin{claim}
Let $\mathscr{C}$ be the class of corruptions where up to 1 of 2 parties
is either maliciously corrupt or semi-honestly corrupt.
Then we have:
$$
\mathscr{P} \overset{2 \cdot \tx{IND}}{\leadsto}_{\mathscr{C}} \mathscr{Q}
$$

\txbf{Proof:} We consider the cases where all the parties are honest
and some of the parties are corrupted separately.
Furthermore, we only need to consider malicious corruption,
since the parties in $\mathscr{Q}$ just directly call functions from
the ideal functionality, and so we can simulate malicious corruption
from semi-honest corruption, and can thus apply part 3
of Theorem~\ref{thm:mal_complete}.

\txbf{Honest Case:} Let $\tx{H}$ be a corruption model where both parties are honest.
We prove that $\mathscr{P} \overset{2 \cdot \tx{IND}}{\leadsto}_{\{\tx{H}\}} \mathscr{Q}$.

The high level idea is that since ciphertexts should be indistinguishable from random
encryptions, the information in the log we get as a simulator for $\mathscr{Q}$
is enough to fake all the ciphertexts the environment expects to see in $\mathscr{P}$.

We start by unrolling $\tx{Inst}_{\tx{H}}(\mathscr{P})$, obtaining:
$$
\tx{Inst}_{\tx{H}}(\mathscr{P}) =
\inlinepackage{$\Gamma^0$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_{\noti}, m)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(c)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{\tx{Dec}(\tx{sk}_i, c)}\cr
    \end{aligned}
}
\circ \tx{Keys}
$$
Note that we can ignore all parts of the instantiation related to channels,
including the router, because the parties don't use any channels.
We also took the liberty of renaming $m_{i \to \noti}$ to $c_{i \to \noti}$,
to emphasize the fact that these queues contain ciphertexts, instead of messages.

Next, we pull a bit of a trick.
It turns out that since both parties are honest, we don't need to actually
decrypt the ciphertext.
Instead, one party can simply send the plaintext via a separate channel
to the other.
Applying this gives us:
$$
\Gamma^0 \circ \tx{Keys} = 
\inlinepackage{$\Gamma^1$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{view } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\bullet, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_{\noti}, m)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(c)\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\circ \tx{Keys}
$$
This is equal because of the correctness property for encryption,
which guarantees that $m = \tx{Dec}(\tx{Enc}(\tx{pk}, m))$.
Furthermore, the timing properties are the same,
since the size of both the $c_{i\to\noti}$ and $m_{i\to\noti}$ queues
are always the same.

At this point, we can offload the decryption to the $\tx{IND}$ game, giving us:
$$
\Gamma^1 \circ \tx{Keys} = 
\inlinepackage{$\Gamma^2$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{view } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\txbf{super}.\tx{pk}_1, \super.\tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \set{c}{\tx{Challenge}_{\noti}(m)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(c)\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\circ
\begin{pmatrix}
\tx{IND}_0\cr
\otimes\cr
\tx{IND}_0
\end{pmatrix}
$$
We use two instances of $\tx{IND}$, and we disambiguate the functions in
each instance by attaching $1$ or $2$ to each function.

Next, we can hop to $\tx{IND}_1$, since:
$$
\Gamma^2 \circ
\begin{pmatrix}
\tx{IND}_0\cr
\otimes\cr
\tx{IND}_0
\end{pmatrix}
\overset{\epsilon}{\approx}
\Gamma^2 \circ
\begin{pmatrix}
\tx{IND}_1\cr
\otimes\cr
\tx{IND}_1
\end{pmatrix}
$$
with $\epsilon = 2\cdot \tx{IND}$.

If we unroll this last game, we get:
$$
\Gamma^1 \circ
\begin{pmatrix}
\tx{IND}_1\cr
\otimes\cr
\tx{IND}_1
\end{pmatrix}
=
\inlinepackage{$\Gamma^3$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{view } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_i) \xleftarrow{\$} \tx{Gen}()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \draw{r}{\txbf{M}(|m|)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(\tx{Enc}(\tx{pk}_{\noti}, r))\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
$$

Our next step will be to ``defer'' the creation of the fake ciphertexts,
generating them on demand when the ciphertext queue is viewed by
the adversary.
To do this, we maintain a log which saves the length of messages
being sent, and also lets us know when to remove ciphertexts from the log.
This gives us:
$$
\Gamma^4 =
\inlinepackage{$\Gamma^5$}{
    &\txbf{pub } l_{1\to2}, l_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{view } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_i) \xleftarrow{\$} \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
        \cr\cr\cr\cr\cr\cr
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} l_{i\to\noti}.\tx{push}((\txt{push}, |m|))\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$c_{i\to\noti}$}{}\cr
        \pind{1} \pwhile{\tx{cmd} \gets \tx{l}_{i\to\noti}.\tx{pop}() \neq \bot}\cr
        \pind{2} \pif{\tx{cmd} = \txt{pop}}\cr
        \pind{3} c_{i\to\noti}.\tx{pop}()\cr
        \pind{2} \pif{\tx{cmd} = (\txt{push}, |m|)}\cr
        \pind{3} \draw{r}{\txbf{M}(|m|)}\cr
        \pind{3} c_{i\to\noti}.\tx{push}(\tx{Enc}(\tx{pk}_{\noti}, r))\cr
        \pind{1} \preturn{c_{i \to \noti}}\cr
        \cr
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} l_{i\to\noti}.\tx{push}((\txt{pop}, |m|))\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
$$

But, at this point the behavior of $\tx{Send}_i$ and $\tx{Recv}_i$ is identical
to that in $\mathscr{Q}$, allowing us to write:
$$
\Gamma^5 = 
\begin{matrix}
\inlinepackage{$S$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_i) \xleftarrow{\$} \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
        \cr\cr\cr\cr\cr\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$c_{i\to\noti}$}{}\cr
        \pind{1} \pwhile{\tx{cmd} \gets \tx{l}_{i\to\noti}.\tx{pop}() \neq \bot}\cr
        \pind{2} \pif{\tx{cmd} = \txt{pop}}\cr
        \pind{3} c_{i\to\noti}.\tx{pop}()\cr
        \pind{2} \pif{\tx{cmd} = (\txt{push}, |m|)}\cr
        \pind{3} \draw{r}{\txbf{M}(|m|)}\cr
        \pind{3} c_{i\to\noti}.\tx{push}(\tx{Enc}(\tx{pk}_{\noti}, r))\cr
    \end{aligned}
}\cr
\otimes\cr
1(\tx{Send}_i, \tx{Recv}_i)\cr
\end{matrix}
\circ \tx{Inst}_{\tx{H}}(\mathscr{Q})
$$
which concludes this part of our proof, having written out our simulator,
and proven that $\tx{Inst}_{\tx{H}}(\mathscr{P}) \overset{\epsilon}{\approx} \tx{SimInst}_{S, \tx{H}}(\mathscr{Q})$.


\txbf{Malicious Case:}
Without loss of generality, we can consider the case where $P_1$ is malicious.
This is because the difference between the parties is just a matter of renaming
variables, so the case where $P_2$ is malicious would be the same.
Let $\tx{M}$ denote this corruption model.
We prove that $\mathscr{P} \overset{0}{\leadsto}_{\{\tx{M}\}} \mathscr{Q}$,
which naturally implies the slightly higher upper bound of $2 \cdot \tx{IND}$.

We start by unrolling $\tx{Inst}_{\tx{M}}(\mathscr{P})$, to get:
$$
\tx{Inst}_{\tx{M}}(\mathscr{P}) =
\inlinepackage{$\Gamma^1$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_2, \tx{pk}_1) \gets \tx{Keys}_2()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn{(\tx{pk}_1, \tx{pk}_2)}\cr
        \cr
        &\pfn{$\tx{Send}_{1}$}{c}\cr
        \pind{1} c_{1 \to 2}.\tx{push}(c)\cr
        \cr
        &\pfn{$\tx{Send}_{2}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_1, m)}\cr
        \pind{1} c_{2 \to 1}.\tx{push}(c)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Keys}_1$}{}\cr
        \pind{1} \preturn{\super.\tx{Keys}_1()}\cr
        \cr
        &\pfn{$\tx{Recv}_{1}$}{}\cr
        \pind{1} \preturn{\await c_{2 \to 1}.\tx{pop}()}\cr
        \cr
        &\pfn{$\tx{Recv}_{2}$}{m}\cr
        \pind{1} \set{c}{\await c_{1 \to 2}.\tx{pop}()}\cr
        \pind{1} \preturn{\tx{Dec}(\tx{sk}_2, c)}\cr
    \end{aligned}
}
\circ \tx{Keys}
$$
The key affordances for malicious corruption are that the adversary
can now see the output of $\tx{Keys}_1$, including their secret key,
and the public key of the other party,
and that they have direct access to $c_{1 \to 2}$.
This allows them to send potentially ``fake'' ciphertexts to the other
party, rather than going through the decryption process.

Next, we explicitly include the code of $\tx{Keys}$, and also include
an additional key pair, used in $\tx{Recv}_2$, this key pair encrypts
and then immediately decrypts the message being received, and thus
has no effect by the correctness property of encryption.
Writing this out, we get:
$$
\Gamma^1 \circ \tx{Keys} =
\inlinepackage{$\Gamma^2$}{
    &\txbf{view } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_1, \tx{pk}_1),\
    (\tx{sk}_2, \tx{pk}_2),\
    (\tx{sk}'_2, \tx{pk}'_2) \gets \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn{(\tx{pk}_1, \tx{pk}_2)}\cr
        \cr
        &\pfn{$\tx{Send}_{1}$}{c}\cr
        \pind{1} c_{1 \to 2}.\tx{push}(c)\cr
        \cr
        &\pfn{$\tx{Send}_{2}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_1, m)}\cr
        \pind{1} c_{2 \to 1}.\tx{push}(c)\cr
        \cr
        \cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Keys}_1$}{}\cr
        \pind{1} \preturn{(\tx{sk}_1, \tx{pk}_2)}\cr
        \cr
        &\pfn{$\tx{Recv}_{1}$}{}\cr
        \pind{1} \preturn{\await c_{2 \to 1}.\tx{pop}()}\cr
        \cr
        &\pfn{$\tx{Recv}_{2}$}{m}\cr
        \pind{1} \set{c}{\await c_{1 \to 2}.\tx{pop}()}\cr
        \pind{1} \set{m}{\tx{Dec}(\tx{sk}_2, c)}\cr
        \pind{1} \set{c'}{\tx{Enc}(\tx{pk}'_2, m)}\cr
        \pind{1} \set{m}{\tx{Dec}(\tx{sk}'_2, c')}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
$$

The next step we perform is a bit of a trick.
We swap the names of $\tx{sk}_2$ and $\tx{sk}'_2$, as well as $\tx{pk}_2$ and $\tx{pk}'_2$,
after all, renaming has no effect on a system.
We also create a separate message queue $m_{1 \to 2}$ which will be used
to send messages directly.
This gives us:
$$
\Gamma^2 =
\inlinepackage{$\Gamma^3$}{
    &\txbf{view } m_{1\to 2}, c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_1, \tx{pk}_1),\
    (\tx{sk}_2, \tx{pk}_2),\
    (\tx{sk}'_2, \tx{pk}'_2) \gets \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn{(\tx{pk}_1, \tx{pk}'_2)}\cr
        \cr
        &\pfn{$\tx{Send}_{1}$}{c}\cr
        \pind{1} c_{1 \to 2}.\tx{push}(c)\cr
        \pind{1} m \gets \tx{Dec}(\tx{sk}'_2, c)\cr
        \pind{1} m_{1 \to 2}.\tx{push}(m)\cr
        \cr
        &\pfn{$\tx{Send}_{2}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_1, m)}\cr
        \pind{1} c_{2 \to 1}.\tx{push}(c)\cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Keys}_1$}{}\cr
        \pind{1} \preturn{(\tx{sk}_1, \tx{pk}'_2)}\cr
        \cr
        &\pfn{$\tx{Recv}_{1}$}{}\cr
        \pind{1} \preturn{\await c_{2 \to 1}.\tx{pop}()}\cr
        \cr
        &\pfn{$\tx{Recv}_{2}$}{m}\cr
        \pind{1} \set{c}{\await c_{1 \to 2}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await m_{1 \to 2}.\tx{pop}()}\cr
        \pind{1} \set{c'}{\tx{Enc}(\tx{pk}_2, m)}\cr
        \pind{1} \set{m}{\tx{Dec}(\tx{sk}_2, c')}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
$$
Notice that at this point $\tx{sk}_2$ and $\tx{pk}_2$ now don't actually
do anything, since they don't actually modify the message in $\tx{Recv}_2$.
The main remaining barrier to writing this as a simulator over $\mathscr{Q}$
is that the ciphertext queues $c_{i \to \noti}$ are modified both in functions
we control $\tx{Send}_1$ and $\tx{Recv}_1$, but also in the two functions
which we don't control $\tx{Send}_2$, and $\tx{Recv}_2$, and will eventually
need to become pass through functions for $\mathscr{Q}$.

For $\tx{Recv}_2$, it modifies $c_{1 \to 2}$ by popping elements off of it.
We can emulate this behavior by reading the access log of $l_{1 \to 2}$ we
get from $\mathscr{Q}$, and using the pop commands inside to modify $c_{1 \to 2}$
when necessary.

For $\tx{Send}_2$, our task is a bit harder, since we need to create an encryption
of $m$, and the log will only contain $|m|$.
However, our simulator over $\mathscr{Q}$ will be able to receive messages
on behalf of the first party, allowing us to retrieve the message,
and then create a simulate ciphertext by encrypting it.

Putting these ideas together, we write:
$$
\Gamma^3 =
\begin{matrix}
\inlinepackage{$S$}{
    &c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_1, \tx{pk}_1),\
    (\tx{sk}'_2, \tx{pk}'_2) \gets \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn{(\tx{pk}_1, \tx{pk}'_2)}\cr
        \cr
        &\pfn{$\tx{Keys}_1$}{}\cr
        \pind{1} \preturn{(\tx{sk}_1, \tx{pk}'_2)}\cr
        \cr
        &\pfn{$c_{i \to \noti}$}{}\cr
        \pind{1} \tx{Update}_{i \to \noti}()\cr
        \pind{1} \preturn{c_{i \to \noti}}\cr
        \cr
        &\pfn{$\tx{Send}_{1}$}{c}\cr
        \pind{1} \tx{Update}_{1 \to 2}()\cr
        \pind{1} c_{1 \to 2}.\tx{push}(c)\cr
        \pind{1} m \gets \tx{Dec}(\tx{sk}'_2, c)\cr
        \pind{1} \super.\tx{Send}_1(m)\cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Update}_{1 \to 2}$}{}\cr
        \pind{1} \pwhile{\tx{cmd} \gets l_{1 \to 2}.\tx{pop}() \neq \bot}\cr
        \pind{2} \pif{\tx{cmd} = \txt{pop}}\cr
        \pind{3} c_{1 \to 2}.\tx{pop}()\cr
        \cr
        &\pfn{$\tx{Update}_{2 \to 1}$}{}\cr
        \pind{1} \pwhile{\tx{cmd} \gets l_{2 \to 1}.\tx{pop}() \neq \bot}\cr
        \pind{2} \pif{\tx{cmd} = (\txt{push}, \bullet)}\cr
        \pind{3} \set{m}{\await \super.\tx{Recv}_1()}\cr
        \pind{3} c_{2 \to 1}.\tx{push}(\tx{Enc}(\tx{pk}_1, m))\cr
        \cr
        &\pfn{$\tx{Recv}_{1}$}{}\cr
        \pind{1} \tx{Update}_{2 \to 1}()\cr
        \pind{1} \preturn{\await c_{2 \to 1}.\tx{pop}()}
        \cr
    \end{aligned}
}\cr
\otimes\cr
1(\{\tx{Send}_2, \tx{Recv}_2\})
\end{matrix}
\circ
\tx{Inst}_{\tx{M}}(\mathscr{Q})
$$
We make sure to update both queues whenever necessary.
This includes when they're viewed by the adversary, but also
whenever we modify the queues ourselves, so that we've popped or pushed
everything that we need to before using the queue.

This simulator is effectively creating a man-in-the-middle attack on the adversary,
by providing them with the wrong public key, allowing them to decrypt the ciphertexts
they see.
On the other side, the simulator can receive messages on behalf of the adversary,
and then re-encrypt them to create the fake ciphertext queue.

Having now proved the upper bound for all the corruption models in $\mathscr{C}$,
we conclude that our claim holds.

$\blacksquare$
\end{claim}

\subsection{Drawing a Random Value}

The basic goal of this subsection is to develop a protocol for securely
choosing a common random value.
This process should such that no party can bias the resulting value.
We will follow the common paradigm of ``commit-reveal'', where the parties
first commit to their random values, then wait for all these commitments to have been made,
before finally opening the random values and mixing them together.
This ensures that no party can bias the result, since they have to choose
their contribution before learning any information about the result.

We start by defining the ideal protocol for drawing a random value.
We'll be working over an additive group $\mathbb{G}$,
and assuming that we have parties numbered $1, \ldots, n$.
The core functionality we use allows each party to set a random value,
and then have the functionality add them together.
This is contained in Game~\ref{game:add}.

\begin{game}{game:add}{Addition Functionality}
\package{$F[\tx{Add}]$}{
    &x_1, \ldots, x_n \gets \bot\cr
    \cr
    &\begin{aligned}
        &\pfn{$(1)\tx{Add}_{i}$}{x}\cr
        \pind{1} \set{x_i}{x}\cr
        \pind{1} \pwait{\forall i.\ x_i \neq \bot}\cr
        \pind{1} \preturn{\textstyle \sum_i x_i}\cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{Leak}{}\cr
        \pind{1} \pif{\exists i.\ x_i = \bot}\cr
        \pind{2} \preturn{(\txt{waiting}, \{i \mid x_i = \bot\})}\cr
        \pind{1} \preturn{(\txt{done}, \textstyle \sum_i x_i)}\cr
    \end{aligned}
}
\end{game}

This game works by first collecting a contribution from each party,
and then adding them together.
At any point after all contributions have been gathered,
the adversary can also see their sum through the $\tx{Leak}$ function.
Note that we only allow a contribution to be provided once,
as marked by the $(1)$ in front of the function.
This will be the case for the random sampling as well.

Using this functionality, we create an ideal protocol for sampling
a random value, defined in Protocol~\ref{prot:rand}

\begin{protocol}{prot:rand}{Ideal Random Protocol}
$\mathscr{P}[\tx{IdealRand}]$ is characterized by:
\begin{itemize}
    \item $F := 1(\tx{Add})$,
    \item $\tx{Leakage} = \{\tx{Leak}\}$,
    \item And $n$ players defined via the following system, for $i \in [n]$:
        \package{$P_i$}{
            &\pfn{$(1)\tx{Rand}_i$}{}\cr
            \pind{1} \draw{x}{\mathbb{G}}\cr
            \pind{1} \preturn{\await \tx{Add}_i(x)}\cr
        }
\end{itemize}
\end{protocol}

The idea is that each party samples a random value, and then submits
that to the addition functionality.
If at least one of the values was sampled randomly, 
then the final result is also random.
Technically, this is an \emph{endemic} random functionality,
in the sense that malicious parties are allowed to choose their own randomness.
We also don't embed the $F[\tx{Add}]$ functionality into the protocol itself,
which makes the ideal protocol technically $\mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}]$.
We do this to allow considering a slightly modified variant of the protocol,
which uses a version of the addition functionality leaking more information,
defined in Game~\ref{game:add'}.

\begin{game}{game:add'}{Addition Functionality}
\package{$F[\tx{Add}']$}{
    &x_1, \ldots, x_n \gets \bot\cr
    \cr
    &\begin{aligned}
        &\pfn{$(1)\tx{Add}_{i}$}{x}\cr
        \pind{1} \set{x_i}{x}\cr
        \pind{1} \pwait{\forall i.\ x_i \neq \bot}\cr
        \pind{1} \preturn{\textstyle \sum_i x_i}\cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{Leak}{}\cr
        \pind{1} \pif{\exists i.\ x_i = \bot}\cr
        \pind{2} \preturn{(\txt{waiting}, \{i \mid x_i = \bot\})}\cr
        \pind{1} \preturn{(\txt{done}, [x_i \mid i \in [n]])}\cr
    \end{aligned}
}
\end{game}

The difference in $F[\tx{Add}']$ is simply that the entire list of contributions
is leaked, rather than just their sum.
We introduce this functionality because it will be simpler
to show that our concrete protocol is simulated by this slightly stronger functionality.
Thankfully, the difference doesn't matter in the end, because we can simulate
the stronger functionality from the weaker one.

\begin{claim}
    Let $\mathscr{C}$ be the corruption class where all up to $n - 1$ parties
    are corrupted.
    It then holds that:
    $$
    \mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}'] \overset{0}{\leadsto}_{\mathscr{C}}
    \mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}]
    $$
    \txbf{Proof:} The crux of the proof is that we can simply invent random
    shares for the honest parties, subject to the constraint that the sum
    of all shares is the same.

    Now, onto the more formal proof.
    We assume, without loss of generality,
    that $1, \ldots, h$ are the indices of the honest parties,
    and $h + 1, \ldots, m$ the semi-honest parties.
    Another convention we use is that $j$ is used as a subscript
    for semi-honest parties, and $k$ for malicious parties.

    The only difference between the instantiation of both protocols lies
    in $\tx{Leak}$.
    Otherwise, the behavior of all the functions is identical.
    Thus, we simply need to write a simulator for that function.
    The basic idea is to intercept calls to the corrupted parties to
    learn their contributions, and then simply invent some fake but plausible
    contributions for the honest parties.

    This gives us:

    $$
    \begin{matrix}
    \inlinepackage{$S$}{
        &\set{\tx{faked}}{\txt{false}}\cr
        &\set{x'_1, \ldots, x'_n}{\bot}\cr
        \cr
        &\begin{aligned}
            &\pfn{$(1)\tx{Add}_k$}{x}\cr
            \pind{1} \set{x'_k}{x}\cr
            \pind{1} \preturn{\tx{Add}_k(x)}\cr
            \cr
            &\pfn{$\tx{Contribution}_j$}{}\cr
            \pind{1} \txbf{assert} (\txt{call}, x) \in \tx{log}.\tx{Add}_j\cr
            \pind{1} \preturn{x}\cr
        \end{aligned}
        \begin{aligned}
        &\pfn{Leak}{}\cr
        \pind{1} \tx{out} \gets \super.\tx{Leak}()\cr
        \pind{1} \pif{\tx{out} = (\txt{waiting}, \tx{on})}\cr
        \pind{2} \preturn{(\txt{waiting}, \tx{on})}\cr
        \pind{1} \pif{\tx{faked} = \txt{false}}\cr
        \pind{2} \set{\tx{faked}}{\txt{true}}\cr
        \pind{2} \pfor{j \in h + 1, \ldots, m}\cr
        \pind{3} x'_j \gets \tx{Contribution}_j()\cr
        \pind{2} \draw{x'_2, \ldots, x'_h}{\mathbb{G}}\cr
        \pind{2} \set{x'_1}{\textstyle \tx{out} - \sum_{i \in [2, \ldots, n]} x_i}\cr
        \pind{1} \preturn{(\txt{done}, [x'_i \mid i \in [n]])}\cr
        \end{aligned}
    }\cr
    \otimes\cr
    1(\ldots)
    \end{matrix}
    $$

    The shares of the malicious parties are obtained by catching them
    when the call to $\tx{Add}_k$ is made, whereas for the semi-honest party
    we instead fetch them from the log.
    Note that because the leakage is only made available once all the parties
    have contributed, we're guaranteed to have already seen the shares
    from the corrupted parties by the time we fake the other shares.

    It should be clear that:
    $$
    \tx{Inst}_C(\mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}']) = 
    \tx{SimInst}_{S, C}(\mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}])
    $$
    concluding our proof.

    $\blacksquare$
\end{claim}

The next task on our hands is to write down the concrete protocol
for sampling randomness via the commit-reveal paradigm.
To do that, we first need to define an appropriate commitment functionality,
which we do in Game~\ref{game:com}

\begin{game}{game:com}{Commitment Functionality}
\package{$F[\tx{Com}]$}{
    &\set{c_1, \ldots, c_n}{\bot}\cr
    &\set{o_1, \ldots, o_n}{\txt{false}}\cr
    \cr
    &\begin{aligned}
        &\pfn{$(1)\tx{Commit}_i$}{x}\cr
        \pind{1} \set{c_i}{x}\cr
        \cr
        &\pfn{$(1)\tx{Open}_i$}{}\cr
        \pind{1} \txbf{assert } c_i \neq \bot\cr
        \pind{1} \set{o_i}{\txt{true}}\cr
        \cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{View}_i$}{x}\cr
        \pind{1} \pif{c_i = \bot}\cr
        \pind{2} \preturn{\txt{empty}}\cr
        \pind{1} \pif{\neg o_i}\cr
        \pind{2} \preturn{\txt{set}}\cr
        \pind{1} \pelse\cr
        \pind{2} \preturn{(\txt{open}, c_i)}\cr
        \cr
    \end{aligned}
}
\end{game}

This functionality acts as a one shot commitment for each participant.
Each party can commit to a value, and then open it at a later point in time.
At any time, each participant can view the state of another participant's
commitment.
This view tells us what stage of the commitment the participant is at,
along with their committed value, once opened.

We can now define a protocol sampling randomness, thanks to this commitment
scheme, in Protocol~\ref{prot:realrand}.

\begin{protocol}{prot:realrand}{Random Protocol}
$\mathscr{P}[\tx{Rand}]$ is characterized by:
\begin{itemize}
    \item $F := F[\tx{Com}]$,
    \item $\tx{Leakage} = \{\tx{View}_1, \ldots, \tx{View}_n\}$,
    \item And $n$ players defined via the following system, for $i \in [n]$:
        \package{$P_i$}{
            &\pfn{$(1)\tx{Rand}_i$}{}\cr
            \pind{1} \draw{x}{\mathbb{G}}\cr
            \pind{1} \tx{Commit}_i(x)\cr
            \pind{1} \pwait{\forall i. \tx{View}_i() \neq \txt{empty}}\cr
            \pind{1} \tx{Open}_i()\cr
            \pind{1} \pwait{\forall i. \tx{View}_i() = (\txt{open}, x_i)}\cr
            \pind{1} \preturn{\textstyle \sum_i x_i}\cr
        }
\end{itemize}
\end{protocol}

The idea is quite simple, everybody generates a random value,
commits to it, and then once everybody has committed, they open the value,
and sum up all the contributions.
The result is, as we'll prove, a random value that no participant
can bias.

Unfortunately, it's not quite the case that $\mathscr{P}[\tx{Rand}]$
is simulated by $\mathscr{P}[\tx{IdealRand}]$.
The reason is a consequence of the timing properties
of the protocols.
Indeed, in $\mathscr{P}[\tx{IdealRand}]$, it suffices to activate
each participant once in order to learn the result,
whereas in $\mathscr{P}[\tx{Rand}]$, two activations are needed,
once to commit, and another time to open.

Instead we introduce a separate protocol, making use of
a ``synchronization'' functionality, defined in Game~\ref{game:sync}.

\begin{game}{game:sync}{Synchronization Game}
\package{$F[\tx{Sync}]$}{
    &\set{\txbf{view } \tx{done}_1, \ldots, \tx{done}_n}{\txt{false}}\cr
    \cr
    &\pfn{$(1)\tx{Sync}_i$}{}\cr
    \pind{1} \tx{done}_i \gets \txt{true}\cr
    \pind{1} \pwait{\forall i.\ \tx{done}_i = \txt{true}}\cr
}
\end{game}

This functionality allows the parties to first ``synchronize'',
by waiting for each party to contribute, before being able to continue.

The protocol using this functionality is then called $\mathscr{Q}$,
and defined in Protocol~\ref{prot:simrand}

\begin{protocol}{prot:simrand}{Synchronized Random Protocol}
    $\mathscr{Q}$ is characterized by:
    \begin{itemize}
        \item $F = F[\tx{Sync}]$,
        \item $\tx{Leakage} := \{\tx{done}_1, \ldots, \tx{done}_n\}$,
        \item And $n$ players defined by the following system, for $i \in [n]$:
        \package{$P_i$}{
            &\pfn{$(1)\tx{Rand}_i$}{}\cr
            \pind{1} \set{\tx{out}}{\await \super.\tx{Rand}_i()}\cr
            \pind{1} \await \tx{Sync}_i()\cr
            \pind{1} \preturn{\tx{out}}\cr
        }
    \end{itemize}
\end{protocol}

The full protocol we consider is $\mathscr{Q} \lhd (\mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}])$,
which can perfectly simulate $\mathscr{P}[\tx{Rand}]$, as we now prove.

\begin{claim}
    Let $\mathscr{C}$ be the class of corruptions where up to $n - 1$ parties
    are corrupt.
    Then it holds that:
    $$
    \mathscr{P}[\tx{Rand}] \overset{0}{\leadsto}_{\mathscr{C}} \mathscr{Q} \lhd (\mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}])
    $$
    \txbf{Proof:} Thanks to the composition properties of protocols, it suffices to prove the above claim using $F[\tx{Add}']$ instead,
    since we already proved that:
    $$
    \mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}'] \overset{0}{\leadsto}_{\mathscr{C}}
    \mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}]
    $$

    As before, we let $1, \ldots, h$ be the indices of honest parties,
    $h + 1, \ldots, m$ the indices of semi-honest parties,
    and use $i, j, k$ for denoting indices of honest, semi-honest, and malicious
    parties, respectively.
    We start by unrolling $\tx{Inst}_C(\mathscr{P}[\tx{Rand}])$, to get:
    
    \package{$\Gamma^0$}{
        &\set{x_1, \ldots, x_n, \tx{rush}_{m + 1}, \ldots, \tx{rush}_n}{\bot}\cr
        &\set{\tx{o}_1, \ldots, \tx{o}_n}{\txt{false}}\cr
        &\set{\tx{log}_j}{\tx{NewLog}()}\cr
        \cr
        &\begin{aligned}
            &\pfn{$(1)\tx{Rand}_i$}{}\cr
            \pind{1} \draw{x_i}{\mathbb{G}}\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i \neq \txt{empty}}\cr
            \pind{1} \set{o_i}{\txt{true}}\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i = (\txt{open}, x_i)}\cr
            \pind{1} \preturn{\textstyle \sum_i x_i}\cr
            \cr
            &\pfn{$\tx{View}_i$}{}\cr
            \pind{1} \pif{x_i = \bot}\cr
            \pind{2} \preturn{\txt{empty}}\cr
            \pind{1} \pif{\neg o_i}\cr
            \pind{2} \preturn{\txt{set}}\cr
            \pind{1} \pelse\cr
            \pind{2} \preturn{(\txt{open}, c_i)}\cr
            \cr
        \end{aligned}
        \begin{aligned}
            &\pfn{$(1)\tx{Rand}_j$}{}\cr
            \pind{1} \tx{log}_j.\tx{Rand}_j.\tx{push}(\txt{input})\cr
            \pind{1} \draw{x_i}{\mathbb{G}}\cr
            \pind{1} \tx{log}_j.\tx{Commit}_j.\tx{push}((\txt{call}, x_i))\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i \neq \txt{empty}}\cr
            \pind{1} \tx{log}_j.\tx{Open}_j.\tx{push}(\txt{call})\cr
            \pind{1} \set{o_i}{\txt{true}}\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i = (\txt{open}, x_i)}\cr
            \pind{1} \preturn{\textstyle \sum_i x_i}\cr
            \cr
            &\pfn{$(1)\tx{Commit}_k$}{x}\cr
            \pind{1} \set{x_k}{x}\cr
            \cr
            &\pfn{$(1)\tx{Open}_k$}{}\cr
            \pind{1} \txbf{assert } x_k \neq \bot\cr
            \pind{1} \set{o_k}{\txt{true}}\cr
        \end{aligned}\cr
    }

    Here we've just inlined the main elements of the game.
    The key difference for the semi-honest parties is that we're able
    to see the randomness they used, since they commit to it.
    For the malicious parties, they can commit to any value they want,
    and can also choose when to open their values.

    We now rewrite this game slightly, to make the connection with what we're
    trying to simulate a bit clearer:

    \package{$\Gamma^1$}{
        &\set{x_1, \ldots, x_n, \tx{rush}_{m + 1}, \ldots, \tx{rush}_n}{\bot}\cr
        &\set{\tx{done}_1, \ldots, \tx{done}_n}{\txt{false}}\cr
        &\set{\tx{log}_j}{\tx{NewLog}()}\cr
        \cr
        &\begin{aligned}
            &\pfn{$(1)\tx{Rand}_i$}{}\cr
            \pind{1} \draw{x_i}{\mathbb{G}}\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i \neq \txt{empty}}\cr
            \pind{1} \set{\tx{done}_i}{\txt{true}}\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i = (\txt{open}, x_i)}\cr
            \pind{1} \preturn{\textstyle \sum_i x_i}\cr
            \cr
            &\pfn{$\tx{View}_i$}{}\cr
            \pind{1} \pif{\tx{Leak}() = (\txt{waiting}, s) \land i \in s}\cr
            \pind{2} \preturn{\txt{empty}}\cr
            \pind{1} \txbf{else } \pif{\tx{done}_i}\cr
            \pind{2} \pif{\tx{rush}_i \neq \bot}\cr
            \pind{3} \preturn{(\txt{open}, \tx{rush}_i)}\cr
            \pind{2} \txbf{assert } (\txt{done}, [y_i]) = \tx{Leak}()\cr
            \pind{2} \preturn{(\txt{open}, y_i)}\cr
            \pind{1} \preturn{\txt{set}}\cr
            \cr
            &\pfn{$\tx{log}_j$}{}\cr
            \pind{1} \set{\tx{log}'_j}{\tx{NewLog}()}\cr
            \pind{1} \set{\tx{log}'_j.\tx{Rand}_j}{\tx{log}_j.\tx{Rand}_j}\cr
            \pind{1} \set{\tx{log}'_j.\tx{Commit}_j}{\tx{log}_j.\tx{Add}_j}\cr
            \pind{1} \set{\tx{log}'_j.\tx{Open}_j}{\tx{log}_j.\tx{Sync}_j}\cr
            \pind{1} \preturn{\tx{log}'_j}\cr
        \end{aligned}
        \begin{aligned}
            &\pfn{$(1)\tx{Rand}_j$}{}\cr
            \pind{1} \tx{log}_j.\tx{Rand}_j.\tx{push}(\txt{input})\cr
            \pind{1} \draw{x_i}{\mathbb{G}}\cr
            \pind{1} \tx{log}_j.\tx{Add}_j.\tx{push}((\txt{call}, x_i))\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i \neq \txt{empty}}\cr
            \pind{1} \tx{log}_j.\tx{Sync}_j.\tx{push}(\txt{call})\cr
            \pind{1} \set{o_i}{\txt{true}}\cr
            \pind{1} \pwait{\forall i.\ \tx{View}_i = (\txt{open}, x_i)}\cr
            \pind{1} \preturn{\textstyle \sum_i x_i}\cr
            \cr
            &\pfn{$(1)\tx{Commit}_k$}{x}\cr
            \pind{1} \set{\tx{rush}_k}{x}\cr
            \pind{1} \set{x_k}{x}\cr
            \cr
            &\pfn{$(1)\tx{Open}_k$}{}\cr
            \pind{1} \txbf{assert } \tx{rush}_k \neq \bot\cr
            \pind{1} \set{\tx{done}_k}{\txt{true}}\cr
            \cr
            &\pfn{Leak}{}\cr
            \pind{1} \pif{\exists i.\ x_i = \bot}\cr
            \pind{2} \preturn{(\txt{waiting}, \{i \mid x_i = \bot\})}\cr
            \pind{1} \preturn{(\txt{done}, [x_i \mid i \in [n]])}\cr
        \end{aligned}
    }
    First of all, we've renamed several variables, like $o_i$ becoming
    $\tx{done}_i$, which has no effect on the game, of course.
    We've also introduced a secondary set of variables $\tx{rush}_k$
    to hold the values the malicious parties are committing to.
    We do this to stress the fact that the simulator will be able to see
    and capture these values.
    We also modify the logging in the semi-honest parties
    to use different names, reflecting what will happen in the eventual
    semi-honest party of $\mathscr{Q}$.
    This requires introducing a $\tx{log}_j$ function which will produce
    a simulated log by renaming these entries.

    Finally, the biggest change is in the $\tx{View}_i$ functions.
    We've rewritten the logic to be based on this $\tx{Leak}$ method
    we've introduced, which informs of us the status of the contributions.
    This gives us enough information to simulate the views accurately.
    For the honest parties, we know that they'll only open their values
    after everybody has already committed, so the assertion will always pass.
    This may not be the case for malicious parties, which may ``rush'',
    opening their values \emph{before} the other parties have finished committing.
    This is why it's important to keep track of their commitments separately,
    so that we can present them inside the view, if necessary.

    At this point, the next step is to realize that all of this logic
    can in fact work inside of a simulator, written as:

    $$
    \begin{matrix}
    \inlinepackage{$S$}{
        &\set{\tx{rush}_{m + 1}, \ldots, \tx{rush}_n}{\bot}\cr
        &\begin{aligned}
            &\pfn{$\tx{View}_i$}{}\cr
            \pind{1} \pif{\tx{Leak}() = (\txt{waiting}, s) \land i \in s}\cr
            \pind{2} \preturn{\txt{empty}}\cr
            \pind{1} \txbf{else } \pif{\tx{done}_i}\cr
            \pind{2} \pif{\tx{rush}_i \neq \bot}\cr
            \pind{3} \preturn{(\txt{open}, \tx{rush}_i)}\cr
            \pind{2} \txbf{assert } (\txt{done}, [y_i]) = \tx{Leak}()\cr
            \pind{2} \preturn{(\txt{open}, y_i)}\cr
            \pind{1} \preturn{\txt{set}}\cr
            \cr
        \end{aligned}
        \begin{aligned}
            &\pfn{$(1)\tx{Commit}_k$}{x}\cr
            \pind{1} \set{\tx{rush}_k}{x}\cr
            \pind{1} \tx{Add}_k(x)\cr
            \cr
            &\pfn{$(1)\tx{Open}_k$}{}\cr
            \pind{1} \txbf{assert } \tx{rush}_k \neq \bot\cr
            \pind{1} \tx{Sync}_k()\cr
            \cr
            &\pfn{$\tx{log}_j$}{}\cr
            \pind{1} \set{\tx{log}'_j}{\tx{NewLog}()}\cr
            \pind{1} \set{\tx{log}'_j.\tx{Rand}_j}{\super.\tx{log}_j.\tx{Rand}_j}\cr
            \pind{1} \set{\tx{log}'_j.\tx{Commit}_j}{\super.\tx{log}_j.\tx{Add}_j}\cr
            \pind{1} \set{\tx{log}'_j.\tx{Open}_j}{\super.\tx{log}_j.\tx{Sync}_j}\cr
            \pind{1} \preturn{\tx{log}'_j}\cr
        \end{aligned}
        \begin{aligned}

        \end{aligned}
    }
        \cr
        \otimes\cr
        1(\ldots)
    \end{matrix}
    $$

    And this concludes our proof, having shown that:
    $$
    \tx{Inst}_C(\mathscr{P}[\tx{Rand}]) = \tx{SimInst}_{S, C}(\mathscr{Q} \lhd (\mathscr{P}[\tx{IdealRand}] \circ F[\tx{Add}]))
    $$

    $\blacksquare$
\end{claim}
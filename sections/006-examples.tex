\section{Examples}

\subsection{Constructing Private Channels}

In this section, we consider the problem of constructing a \emph{private}
channel from a \emph{public} channel.
A public channel leaks all messages sent over it to an adversary,
whereas a private channel leaks a minimal amount of information:
in our case, essentially just the length of messages sent over the channel.

We'll be constructing a two-party private channel from a public channel
using an encryption scheme, and will also show that this construction is secure,
even if one of the two parties using the channel is corrupted.

Let's start with the ideal functionality representing a public channel,
as Game~\ref{game:pubchan}.

A few clarifications on the notation in this game:
\begin{itemize}
    \item For $i \in \{1, 2\}$, we let $\noti$ denote either $2$ or $1$, respectively.
    \item There are two versions of $\tx{Send}_i$ and $\tx{Recv}_i$, for $i \in \{1, 2\}$.
    \item The $\tx{pop}$ function on queues is asynchronous, meaning that we wait until the queue is not empty
    to remove the oldest element from it.
    \item The queues are public in an \emph{immutable} fashion: they can be read but not modified outside the package.
\end{itemize}

\begin{game}{game:pubchan}{Public Channel Functionality}
\package{$F[\tx{PubChan}]$}{
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i\to \noti}$}{m}\cr
        \pind{1}m_{i\to \noti}.\tx{push}(m)\cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i\to \noti}$}{}\cr
        &\preturn{\await{m_{i\to \noti}.\tx{pop}()}}
    \end{aligned}
}
\end{game}

The idea behind this functionality is that each party can send messages to,
or receive messages from the other party.
However, at any point, the currently stored messages are readable by
the adversary.
Note that this assignment of which functions
are usable by which entities is not defined by the functionality \emph{itself},
but rather merely suggested by its syntax, and enforced only by how
protocols will eventually use the functionality.

Next, we look at a functionality for \emph{private} channels,
captured by Game~\ref{game:privchan}.

\begin{game}{game:privchan}{Private Channel Functionality}
\package{$F[\tx{PrivChan}]$}{
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } l_{1\to2}, l_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i\to \noti}$}{m}\cr
        \pind{1}m_{i\to \noti}.\tx{push}(m)\cr
        \pind{1}l_{i\to \noti}.\tx{push}((\txt{push}, |m|))\cr
        \cr
    \end{aligned}
    \quad
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i\to \noti}$}{}\cr
        \pind{1} \set{m}{\await{m_{i\to \noti}.\tx{pop}()}}\cr
        \pind{1}l_{i\to \noti}.\tx{push}(\txt{pop})\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\end{game}

The crucial difference is the nature of the leakage.
Now, rather than being able to see the current state of either message queue,
including the messages themselves, now the adversary can only
see a historical log for each queue, describing only the \emph{length}
of the messages inserted into the queue.
The reason for having a historical log, rather than just a snapshot
of the lengths of the current messages,
is to make the simulator's job easier
in the eventual proof of security.

Now, we need to define the protocols.
One protocol will use the private channel to send messages,
and the other will try and implement the same behavior,
but using only the public channel, aided by an encryption scheme.

Let's start with the simpler private channel protocol, which we'll
call $\mathcal{Q}$,
and defined via Protocol~\ref{prot:privchan}

\begin{protocol}{prot:privchan}{Private Channel Protocol}
    $\mathcal{Q}$ is characterized by:
    \begin{itemize}
        \item $\tx{Leakage} := \{l_{1\to 2}, l_{2\to1}\}$,
        \item $F := \tx{PrivChan}$,
        \item And two players defined via the following system (for $i \in \{1, 2\}$):
\package{$P_i$}{
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \tx{Send}_{i \to \noti}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \preturn{\await \tx{Recv}_{\noti \to i}()}\cr
    \end{aligned}
}
    \end{itemize}

\end{protocol}

This protocol basically just provides each player access with their corresponding
functions in the functionality, and leaks the parts of the functionality
that the adversary should have access to, as expected.

Next, we need to define a protocol providing an encrypted channel.
We'll call this one $\mathcal{P}$.
The basic idea is that $\mathcal{P}$ will encrypt messages before sending
them over the public channel.
We'll be using public-key encryption, as defined in \todo{todo}.
For the sake of simplicity, we'll be relying on an additional functionality,
$\tx{Keys}$, which will be used to setup each party's key pair, and allow
each party to agree on the other's public key.

This functionality is defined in Game~\ref{game:keys}.
The basic idea is that a key pair is generated for each party,
and that party can see their secret key, along with the public key for the other party.
Furthermore, we allow the adversary to see both public keys.

\begin{game}{game:keys}{Keys Functionality}
\package{Keys}{
&\draw{(\tx{sk}_1, \tx{pk}_1)}{\tx{Gen}()}\cr
&\draw{(\tx{sk}_2, \tx{pk}_2)}{\tx{Gen}()}\cr
\cr
&\pfn{$\tx{Keys}_i$}{}\cr
\pind{1} \preturn{(\tx{sk}_i, \tx{pk}_{\noti})}\cr
\cr
&\pfn{PKs}{}\cr
\pind{1} \preturn{(\tx{pk}_1, \tx{pk}_2)}\cr
}
\end{game}

With this in hand, we can define $\mathcal{P}$ itself, in Protocol~\ref{prot:encchan}.

\begin{protocol}{prot:encchan}{Encrypted Channel Protocol}
    $\mathcal{P}$ is characterized by:
    \begin{itemize}
        \item $\tx{Leakage} := \{m_{1\to 2}, m_{2\to1}, \tx{PKs}\}$,
        \item $F := \tx{Keys} \otimes \tx{PrivChan}$,
        \item and two players defined via the following system (for $i \in \{1, 2\}$):
\package{$P_i$}{
    &(\tx{sk}_i, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \tx{Send}_{i \to \noti}(\tx{Enc}(\tx{pk}_{\noti}, m))\cr
        \cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{Recv}_{\noti \to i}()}\cr
        \pind{1} \preturn{\tx{Dec}(\tx{sk}_i, c)}\cr
    \end{aligned}
}
    \end{itemize}

\end{protocol}

Each player will encrypt their message for the other player before sending it,
and then decrypt it using their secret key after receiving it.

At this point we can state and prove the crux of this example:

\begin{claim}
Let $\mathcal{C}$ be the class of corruptions where up to 1 of 2 parties
is either maliciously corrupt or semi-honestly corrupt.
Then we have:
$$
\mathcal{P} \overset{2 \cdot \tx{IND}}{\leadsto}_{\mathcal{C}} \mathcal{Q}
$$

\txbf{Proof:} We consider the cases where all the parties are honest
and some of the parties are corrupted separately.
Furthermore, we only need to consider malicious corruption,
since the parties in $\mathcal{Q}$ just directly call functions from
the ideal functionality, and so we can simulate malicious corruption
from semi-honest corruption, and can thus apply part 3
of Theorem~\ref{thm:mal_complete}.

\txbf{Honest Case:} Let $\tx{H}$ be a corruption model where both parties are honest.
We prove that $\mathcal{P} \overset{2 \cdot \tx{IND}}{\leadsto}_{\{\tx{H}\}} \mathcal{Q}$.

The high level idea is that since ciphertexts should be indistinguishable from random
encryptions, the information in the log we get as a simulator for $\mathcal{Q}$
is enough to fake all the ciphertexts the environment expects to see in $\mathcal{P}$.

We start by unrolling $\tx{Inst}_{\tx{H}}(\mathcal{P})$, obtaining:
$$
\tx{Inst}_{\tx{H}}(\mathcal{P}) =
\inlinepackage{$\Gamma^0$}{
    &\txbf{pub } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_{\noti}, m)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(c)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{\tx{Dec}(\tx{sk}_i, c)}\cr
    \end{aligned}
}
\circ \tx{Keys}
$$
Note that we can ignore all parts of the instantiation related to channels,
including the router, because the parties don't use any channels.
We also took the liberty of renaming $m_{i \to \noti}$ to $c_{i \to \noti}$,
to emphasize the fact that these queues contain ciphertexts, instead of messages.

Next, we pull a bit of a trick.
It turns out that since both parties are honest, we don't need to actually
decrypt the ciphertext.
Instead, one party can simply send the plaintext via a separate channel
to tthe other.
Applying this gives us:
$$
\Gamma^0 \circ \tx{Keys} = 
\inlinepackage{$\Gamma^1$}{
    &\txbf{pub } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\bullet, \tx{pk}_{\noti}) \gets \tx{Keys}_i()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \set{c}{\tx{Enc}(\tx{pk}_{\noti}, m)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(c)\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\circ \tx{Keys}
$$
This is equal because of the correctness property for encryption,
which guarantees that $m = \tx{Dec}(\tx{Enc}(\tx{pk}, m))$.
Furthermore, the timing properties are the same,
since the size of both the $c_{i\to\noti}$ and $m_{i\to\noti}$ queues
are always the same.

At this point, we can offload the decryption to the $\tx{IND}$ game, giving us:
$$
\Gamma^1 \circ \tx{Keys} = 
\inlinepackage{$\Gamma^2$}{
    &\txbf{pub } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\txbf{super}.\tx{pk}_1, \super.\tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \set{c}{\tx{Challenge}_{\noti}(m)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(c)\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
\circ
\begin{pmatrix}
\tx{IND}_0\cr
\otimes\cr
\tx{IND}_0
\end{pmatrix}
$$
We use two instances of $\tx{IND}$, and we disambiguate the functions in
each instance by attaching $1$ or $2$ to each function.

Next, we can hop to $\tx{IND}_1$, since:
$$
\Gamma^2 \circ
\begin{pmatrix}
\tx{IND}_0\cr
\otimes\cr
\tx{IND}_0
\end{pmatrix}
\overset{\epsilon}{\approx}
\Gamma^2 \circ
\begin{pmatrix}
\tx{IND}_1\cr
\otimes\cr
\tx{IND}_1
\end{pmatrix}
$$
with $\epsilon = 2\cdot \tx{IND}$.

If we unroll this last game, we get:
$$
\Gamma^1 \circ
\begin{pmatrix}
\tx{IND}_1\cr
\otimes\cr
\tx{IND}_1
\end{pmatrix}
=
\inlinepackage{$\Gamma^3$}{
    &\txbf{pub } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_i) \xleftarrow{\$} \tx{Gen}()\cr
    \cr
    &\pfn{PKs}{}\cr
    \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
    &\begin{aligned}
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} \draw{r}{\txbf{M}(|m|)}\cr
        \pind{1} c_{i\to\noti}.\tx{push}(\tx{Enc}(\tx{pk}_{\noti}, r))\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{c}{\await \tx{c}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
$$

Our next step will be to ``defer'' the creation of the fake ciphertexts,
generating them on demand when the ciphertext queue is viewed by
the adversary.
To do this, we maintain a log which saves the length of messages
being sent, and also lets us know when to remove ciphertexts from the log.
This gives us:
$$
\Gamma^4 =
\inlinepackage{$\Gamma^5$}{
    &\txbf{pub } l_{1\to2}, l_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &\txbf{pub } m_{1\to2}, m_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_i) \xleftarrow{\$} \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
        \cr\cr\cr\cr\cr\cr
        &\pfn{$\tx{Send}_{i}$}{m}\cr
        \pind{1} l_{i\to\noti}.\tx{push}((\txt{push}, |m|))\cr
        \pind{1} m_{i\to\noti}.\tx{push}(m)\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$c_{i\to\noti}$}{}\cr
        \pind{1} \pwhile{\tx{cmd} \gets \tx{l}_{i\to\noti}.\tx{pop}() \neq \bot}\cr
        \pind{2} \pif{\tx{cmd} = \txt{pop}}\cr
        \pind{3} c_{i\to\noti}.\tx{pop}()\cr
        \pind{2} \pif{\tx{cmd} = (\txt{push}, |m|)}\cr
        \pind{3} \draw{r}{\txbf{M}(|m|)}\cr
        \pind{3} c_{i\to\noti}.\tx{push}(\tx{Enc}(\tx{pk}_{\noti}, r))\cr
        \cr
        &\pfn{$\tx{Recv}_{i}$}{}\cr
        \pind{1} \set{m}{\await \tx{m}_{\noti \to i}.\tx{pop}()}\cr
        \pind{1} l_{i\to\noti}.\tx{push}((\txt{pop}, |m|))\cr
        \pind{1} \preturn{m}\cr
    \end{aligned}
}
$$

But, at this point the behavior of $\tx{Send}_i$ and $\tx{Recv}_i$ is identical
to that in $\mathcal{Q}$, allowing us to write:
$$
\Gamma^5 = 
\begin{matrix}
\inlinepackage{$S$}{
    &\txbf{pub } c_{1\to2}, c_{2\to1} \gets \tx{FifoQueue}.\tx{new}()\cr
    &(\tx{sk}_i, \tx{pk}_i) \xleftarrow{\$} \tx{Gen}()\cr
    \cr
    &\begin{aligned}
        &\pfn{PKs}{}\cr
        \pind{1} \preturn (\tx{pk}_1, \tx{pk}_2)\cr
        \cr\cr\cr\cr\cr\cr
    \end{aligned}
    \begin{aligned}
        &\pfn{$c_{i\to\noti}$}{}\cr
        \pind{1} \pwhile{\tx{cmd} \gets \tx{l}_{i\to\noti}.\tx{pop}() \neq \bot}\cr
        \pind{2} \pif{\tx{cmd} = \txt{pop}}\cr
        \pind{3} c_{i\to\noti}.\tx{pop}()\cr
        \pind{2} \pif{\tx{cmd} = (\txt{push}, |m|)}\cr
        \pind{3} \draw{r}{\txbf{M}(|m|)}\cr
        \pind{3} c_{i\to\noti}.\tx{push}(\tx{Enc}(\tx{pk}_{\noti}, r))\cr
    \end{aligned}
}\cr
\otimes\cr
1(\tx{Send}_i, \tx{Recv}_i)\cr
\end{matrix}
\circ \tx{Inst}_{\tx{H}}(\mathcal{Q})
$$
which concludes this part of our proof, having written out our simulator,
and proven that $\tx{Inst}_{\tx{H}}(\mathcal{P}) \overset{\epsilon}{\approx} \tx{SimInst}_{S, \tx{H}}(\mathcal{Q})$.


\txbf{Malicious Case:}
Without loss of generality, we can consider the case where $P_1$ is malicious.
This is because the difference between the parties is just a matter of renaming
variables.
Let $\tx{M}$ denote this corruption model.
We prove that $\mathcal{P} \overset{0}{\leadsto}_{\{\tx{M}\}} \mathcal{Q}$,
which naturally implies the slightly higher upper bound of $2 \cdot \tx{IND}$.

Having now proved the upper bound for all the corruption models in $\mathcal{C}$,
we conclude that our claim holds.

$\blacksquare$
\end{claim}
\section{Introduction}

Universally composable (UC) security \cite{EPRINT:Canetti00}
has seen widespread success since its introduction over
two decades ago,
becoming the dominant framework for analyzing the security of cryptographic
protocols.

This success is understandable, because the guarantees
the framework provides are very useful.
In essence, when a protocol is proved secure in the UC framework,
then arbitrary instances of that protocol can be used concurrently in the context
of a larger system, without modifying the behavior
of these protocols.
This allows the analysis of isolated components to be used
to guarantee the security of a system as a whole;
this modular analysis is essential to being able to scale
formal analysis to larger systems.

The framework is not ubiquitous however.
For many cryptographic schemes, standalone security with games
is a more suitable approach.
Even for some protocols, the use of game-based security has been popular.
The analysis of threshold signatures and messaging protocols
has seen the development of increasingly intricate games,
which describe all the ways in which an adversary can attack a protocol.
This is the main disadvantage of game-based security for protocols:
it's not always clear what the ``right'' game is to analyze
the security of a protocol, and these games often need to provide
explicit capabilities to the adversary.
This problem is alleviated somewhat in UC security,
where the security of a protocol boils down to describing
an ``ideal functionality'',
which represents how the protocol could function if one had access
to a perfectly trusted third party,
thus making it easier to determine if a given notion of security
reflects the kinds of attacks that need to be analyzed.

The game based approach is still sometimes preferred because of
its perceived ease of use as compared to UC proofs.
Some of these difficulties are inherent:
because UC security provides stronger guarantees than standalone
security, it's not surprising that proofs would involve more ``work''.

Some of these difficulties don't seem to be inherent though,
which is why a series of works have provided improvements,
simplifications, and variants of UC security.
GNUC \cite{JC:HofSho15} was an early variant,
simplifying many aspects of UC, and also patching several
foundational gaps present in the paper at the time.

One disadvantage of developing a new framework is that
proofs in one framework may not necessarily
or automatically translate to UC proofs.
One approach to addressing this is to develop
a ``higher level'' language for simpler proofs,
which is then compiled down to an actual UC proof.
This was done in \cite{C:CanCohLin15},
which provided a simplified version of UC, suitable
for the common setting of multiparty computation,
but also a way to interpret proofs in this simplified
model as actually being UC proofs.

Another series of works ended up taking
a similar approach.
The IITM framework \cite{EPRINT:Kuesters06, JC:KusTueRau20a}
was first introduced as an alternative to UC, with very different foundations.
Recently, this framework was shown to be effectively equivalent to UC
\cite{EC:RauKusChe22}.

Another interesting alternative to UC is that presented in
\cite{cramer2015secure}.
This approach defines a kind of UC security in terms of
a calculus for \emph{interactive systems},
and their composition.
This is an interesting departure from the interactive turing machine
foundations, and does away with many inessential details.
This approach is the most similar to the framework we develop
in this work.

In practice, UC proofs are often quite informal,
without explicitly mentioning the various details that the formalism
might require.
For example, the framework might specify protocols
in terms of interactive turing machines, but in practice,
proofs are written with an informal description of what the protocol
does.
We think that this informality actually
makes proofs harder to write and understand,
because it isn't clear what exactly a proof can consist of,
nor what certain informal patterns mean precisely.

In this work, we propose a new framework for analyzing the security
of protocols, which we believe to be both less informal,
but also simpler to understand and use.

\subsection{Our Framework}

More modular, formal, and simpler.

breaking down protocols.

transitivity of simulation

connection with games.

founded on state separable proofs,
most similar to.

hierarchy of stuff

we also formalize state separable proofs while we're at it, why not.

\subsection{Overview}

as mentioned above, we need to first define packages,
systems, etc.

in section 2

in section 3

in section 4

in section 5

in section 6

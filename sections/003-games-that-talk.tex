\section{Systems}

\subsection{Asynchronous Packages}

While the intuition of yield statements is simple, defining
them precisely is a bit more tricky.

\begin{definition}[Yield Statements]
\label{def:yield}
We define the semantics of $\textbf{yield}$ by compiling functions with
such statements to functions without them.

Note that we don't define the semantics for functions which still contain references
to oracles.
Like before, we can delay the definition of semantics until all of the
pseudo-code has been inlined.

A first small change is to make it so that the function accepts one
argument, a binary string, and all yield points also accept binary
strings as continuation.
Like with plain packages, we can implement richer types on top by adding
additional checks to the well-formedness of binary strings, aborting
otherwise.

The next step is to make it so that all the local variables of the function $F$
are present in the global state.
So, if a local variable $v$ is present, then every use
of $v$ is replaced with a use of the global variable $F.v$ in the package.
This allows the state of the function to be saved across yields.

The next step is transforming all the control flow of a function to
use $\textbf{ifgoto}$, rather than structured programming constructs like
$\textbf{while}$ or $\textbf{if}$.
The function is broken into lines, each of which contains a single statement.
Each line is given a number, starting at $0$.
The execution of a function $F$ involves a special variable $\texttt{pc}$,
representing the current line being executing.
Excluding $\textbf{yield}$ and $\textbf{return}$ a single line statement has one of the
forms:
$$
\begin{aligned}
&\langle \texttt{var} \rangle \gets \langle \texttt{expr} \rangle\cr
&\langle \texttt{var} \rangle \xleftarrow{\$} \langle \texttt{dist} \rangle\cr
\end{aligned}
$$
which have well defined semantics already.
Additionally, after these statements, we set $\texttt{pc} \gets \texttt{pc} + 1$.

The semantics of $\textbf{ifgoto } \langle \texttt{expr} \rangle i$ is:
$$
\texttt{pc} \gets \textbf{ if } \langle \texttt{expr} \rangle \textbf{ then } i \textbf{ else } \texttt{pc} + 1
$$
This gives us a conditional jump, and by using $\texttt{true}$ as the condition,
we get a standard unconditional jump.

This allows us to define $\textbf{if}$ and $\textbf{while}$ statements
in the natural way.

Finally, we need to augment functions to handle $\textbf{yield}$ and $\textbf{return}$
statements.
To handle this, each function $F$ also has an associated variable
$F.\texttt{pc}$, which stores the program counter for the function.
This is different than the local $\texttt{pc}$ which is while the function is
execution.
$F.\texttt{pc}$ is simply used to remember the program counter after a yield
statement.

The function now starts with:
$$
\begin{aligned}
&\textbf{ifgoto } \texttt{true}\ F.\text{pc} 
\end{aligned}
$$
This has the effect of resuming execution at the saved program counter.

Furthermore, the input variable $x$ to $F$ is replaced with a special
variable $\texttt{input}$, which holds the input supplied to the function.
At the start of the function body, we add:
$$
0: F.x \gets \texttt{input}
$$
to capture the fact that the original input variable needs to get assigned
to the input to the function.

The semantics of $F.m \gets \textbf{yield } v$ are:
$$
\begin{aligned}
(i-1):&\ F.\text{pc} \gets i + 1\cr
i:&\ \textbf{return } (\texttt{yield}, v)\cr
(i + 1):&\ F.m \gets \texttt{input}
\end{aligned}
$$

The semantics of $\textbf{return } v$ become:
$$
\begin{aligned}
&F.\text{pc} \gets 0\cr
&\textbf{return } (\texttt{return}, v)
\end{aligned}
$$
The main difference is that we annotate the return value to be different than
yield statements, but otherwise the semantics are the same.

$\square$
\end{definition}

Note that while calling a function which can yield will notify the
caller as to whether or not the return value was \emph{yielded}
or \emph{returned}, syntactically the caller often ignores this,
simply doing $x \gets F(\ldots)$, meaning that they simply use
return value $x$, discarding the tag.

\begin{syntax}[Empty Yields]
In many cases, no value is yielded, or returned back, which we can write as:
$$
\textbf{yield}
$$
which is shorthand for:
$$
\bullet \gets \textbf{yield } \bullet
$$
i.e. just yielding a dummy value and ignoring the result.

$\square$
\end{syntax}

Unless otherwise specified, we only consider empty yields from now on.

We define these semantics via the $\textbf{await}$ statement.

\begin{syntax}[Await Statements]
\label{syn:await}
We define the semantics of $v \gets \await F(\ldots)$ in a straightforward way:
$$
\begin{aligned}
&(\tx{tag}, v) \gets (\texttt{yield}, \bot)\cr
&\txbf{while } \tx{tag} = \texttt{yield}:\cr
\pind{1}\txbf{if } v \neq \bot:\cr
\pind{2}\txbf{yield}\cr
\pind{1}(\tx{tag}, v) \gets F(\ldots)\cr
\end{aligned}
$$
In other words, we keep calling the function until it actually returns
its final value, but we do yield to our caller whenever our function yield, but we do yield to our caller whenever our function yields.

$\square$
\end{syntax}

Sometimes we want to await several values at once, returning the first
one which completes. To that end, we define the $\textbf{select}$ statement.

\begin{syntax}[Select Statements]
\label{syn:select}
Select statements generalize await statements in that they allow waiting
for multiple events concurrently.

More formally, we define:
$$
\begin{aligned}
&\txbf{select}:\cr
\pind{1}v_1 \gets \await F_1(\ldots):\cr
\pind{2} \langle \tx{body}_1 \rangle\cr
\pind{1}\vdots\cr
\pind{1}v_n \gets \await F_n(\ldots):\cr
\pind{2} \langle \tx{body}_n \rangle\cr
\end{aligned}
$$
As follows:
$$
\begin{aligned}
&(\tx{tag}_i, v_i) \gets (\texttt{yield}, \bot)\cr
&i \gets 0\cr
&\txbf{while } \nexists i.\ \tx{tag}_i \neq \texttt{yield}:\cr
\pind{1} \txbf{if } i \geq n:\cr
\pind{2} i \gets 0\cr
\pind{2} \txbf{yield}\cr
\pind{1} i \gets i + 1\cr
\pind{1} (\tx{tag}_i, v_i) \gets F_i(\ldots)\cr
&\langle \tx{body}_i \rangle
\end{aligned}
$$
Note that the order in which we call the functions is completely deterministic,
and fair.
It's also important that we yield, like with await statements, but we only
do so after having pinged each of our underlying functions at least once.
This is so that if one of the function is immediately ready, we never yield.

$\square$
\end{syntax}

\begin{definition}[Asynchronous Packages]
  An \emph{asynchronous} package $P$ is a package which uses the additional
  syntax from Definition~\ref{def:yield} and Syntax~\ref{syn:await},~\ref{syn:select}.

  $\square$
\end{definition}

Note that our syntax sugar definitions means that whenever one of the constructs
such as yield and what not are used, they are immediately replaced with their underlying
semantics. Thus, an asynchronous package \emph{literally} is a package which 
does not use any of those syntactical constructs.

$\tx{In/Out}$ are well defined \todo{elaborate}.
Naturally, the definitions of $\circ$ and $\otimes$ for packages also
generalize directly to asynchronous packages.

\subsection{Channels and System Composition}


\begin{definition}[Systems]
A \emph{system} is a package which uses channels.

We denote by $\text{InChan(S)}$ the set of channels the system receives on,
and $\text{OutChan(S)}$ the set of channels the system sends on,
and define
$$
\text{Chan}(S) := \text{OutChan}(S) \cup \text{InChan}(S)
$$

Additionally we require that $\text{OutChan}(S) \cap \text{InChan}(S) = \emptyset$

$\square$
\end{definition}

We also define shorthands $\tx{Chan}(A, B, \ldots) = \tx{Chan}(A) \cup \tx{Chan}(B) \cup \ldots$.
\todo{expand}.

\begin{definition}
We can compile systems to not use channels.
We denote by $\text{NoChan}(S)$ the package corresponding to
a system $S$, with the use of channels replaced with function calls.

Channels define three new syntactic constructions, for sending and receiving
along a channel, along with testing how many messages are in a channel.
We replace these with function calls as follows:


Sending, with $m \Rightarrow P$ becomes:
$$
\text{Channels}.\tx{Send}_P(m)
$$

Testing, with $n \gets \txbf{test } P$ becomes
$$
n \gets \tx{Channels}.\tx{Test}_P()
$$

Receiving, with $m \Leftarrow P$ becomes:
$$
m \gets \await \text{Channels}.\tx{Recv}_P()
$$
Receiving is an asynchronous function, because the channel might not have
any available messages for us.

These function calls are parameterized by the channel, meaning
that that we have a separate function for each channel.

$\square$
\end{definition}

\begin{game}{game:Channels}{Channels}
\package{Channels($\{A_1, \ldots, A_n\}$)}{
&q[A_i] \gets \text{FifoQueue.New()}\cr
\cr
&\underline{\tx{Send}_{A_i}(m)\tx{:}}\cr
\pind{1} q[A_i].\tx{Push}(m)\cr
\cr
&\underline{\tx{Test}_{A_i}()\tx{:}}\cr
\pind{1} \txbf{return } q[A_i].\tx{Length}()\cr
\cr
&\underline{\tx{Recv}_{A_i}()\tx{:}}\cr
\pind{1} \txbf{while } q[A_i].\tx{IsEmpty()}\cr
\pind{2} \txbf{yield}\cr
\pind{1} q[A_i].\tx{Next}()\cr
}
\end{game}

One consequence of this definition with separate functions for each channel
is that $\text{Channels}(S) \otimes \text{Channels}(R) = \text{Channels}(S \cup R)$.

Armed with the syntax sugar for channels, and the $\tx{Channels}$ game,
we can convert a system $S$ into a package via:
$$
\text{SysPack}(S) := \text{NoChan}(S) \circ (\text{Channels}(\tx{Chan}(S)) \otimes 1(\tx{In}(S)))
$$
This package will have the same input and output functions as the system $S$,
but with the usage of channels replaced with actual semantics.

This allows us to lift our standard equality relations on packages onto
\emph{systems}.

\begin{definition}
  Given systems $A, B$, we say that they have the same \emph{shape} if
  \begin{itemize}
    \item $\tx{In}(A) = \tx{In}(B)$,
    \item $\tx{Out}(A) = \tx{Out}(B)$,
    \item $\tx{InChan}(A) = \tx{InChan}(B)$,
    \item $\tx{OutChan}(A) = \tx{OutChan}(B)$.
  \end{itemize}

  $\square$
\end{definition}

\begin{definition}[Literal System Equality]
  Given systems $A$, $B$ with the same shape, we say that they are \emph{literally} equal, written $A \equiv B$ if
  $$
  \tx{NoChan}(A) = \tx{NoChan}(B)
  $$

  $\square$
\end{definition}

\begin{definition}[System Tensoring]
Given two systems, $A$ and $B$, with \(\text{Out}(A) \cap \text{Out}(B) = \emptyset\), we can define their tensor product $A * B$,
which is any system $A * B$ satisfying:
\begin{itemize}
  \item $\tx{NoChan}(A * B) = \tx{NoChan}(A) \otimes \tx{NoChan}(B)$,
  \item $\tx{InChan}(A * B) = \tx{InChan}(A) \cup \tx{InChan}(B)$,
  \item $\tx{OutChan}(A * B) = \tx{OutChan}(A) \cup \tx{OutChan}(B)$,
  \item $\tx{In}(A * B) = \tx{In}(A) \cup \tx{In}(B)$.
\end{itemize}

$\square$
\end{definition}

Note that combining the definition above with the definition of $\text{SysPack}$
means that:
$$
\tx{SysPack}(A * B) =
\begin{pmatrix}
\tx{NoChan}(A)\cr
\otimes\cr
\tx{NoChan}(B)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
\text{Channels}(\tx{Chan}(A) \cup \tx{Chan}(B))\cr
\otimes\cr
1(\tx{In}(A) \cup \tx{In}(B))\cr
\end{pmatrix}
$$

This implies the following lemma.

\begin{lemma}
System tensoring is associative, i.e. $A * (B * C) \equiv (A * B) * C$.
\txbf{Proof:} This follows directly from the associativity
of $\otimes$ for packages and $\cup$.

$\blacksquare$
\end{lemma}

\begin{lemma}
System tensoring is commutative, i.e. $A * B \equiv B * A$

\txbf{Proof:} This follows from the commutativity of $\otimes$ and $\cup$.

$\blacksquare$
\end{lemma}

\begin{definition}[Overlapping Systems]
Two systems $A$ and $B$ overlap if $\text{Chan}(A) \cap \text{Chan}(B) \neq \emptyset$.

In the case of non-overlapping systems, we write $A \otimes B$ instead of $A * B$,
insisting on the fact that they don't communicate.
\end{definition}

\begin{definition}[System Composition]
Given two systems, $A$ and $B$, we can define their (horizontal) composition
$A \circ B$ as any system, provided a few constraints hold:
\begin{itemize}
\item $A$ and $B$ do not overlap ($\text{Chan}(A) \cap \tx{Chan}(B) = \emptyset$)
\item $\tx{In}(A) \subseteq \tx{Out}(B)$
\end{itemize}

With these in place, we define the composition as any system $A \circ B$ such that:
\begin{itemize}
  \item $\tx{NoChan}(A \circ B) = \tx{NoChan}(A) \circ \begin{pmatrix}
    \tx{NoChan}(B)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(A)))
  \end{pmatrix}
    $,
  \item $\tx{InChan}(A \circ B) = \tx{InChan}(A) \cup \tx{InChan}(B)$,
  \item $\tx{OutChan}(A \circ B) = \tx{OutChan}(A) \cup \tx{OutChan}(B)$,
  \item $\tx{In}(A \circ B) = \tx{In}(B)$.
\end{itemize}

$\square$
\end{definition}

\begin{lemma}
System composition is associative, i.e. $A \circ (B \circ C) \equiv (A \circ B) \circ C$.

\txbf{Proof:} This follows from the associativity of $\circ$ for \emph{packages}.

$\blacksquare$
\end{lemma}

\begin{lemma}[Interchange Lemma]
\label{thm:interchange_system}
Given systems $A, B, C, D$ such that $A \circ B$ and $C \circ D$ are well defined,
$A * C$ and $B * D$ are well defined,
and neither $A$ nor $C$ overlap with $B$ or $D$, i.e.
the following relation holds:
$$
\begin{pmatrix} 
A\cr
*\cr
C\cr
\end{pmatrix} 
\circ
\begin{pmatrix} 
B\cr
*\cr
D\cr
\end{pmatrix} 
\equiv
\begin{matrix} 
  (A \circ B)\cr
*\cr
  (C \circ D)\cr
\end{matrix} 
$$

\txbf{Proof:} $\tx{InChan}$, $\tx{OutChan}$, and $\tx{In}$ are equal for
both of these systems, by associativity of $\cup$.
We now look at $\tx{NoChan}$.
Starting with the right hand side, we get:
$$
\tx{NoChan}
\begin{pmatrix} 
  (A \circ B)\cr
*\cr
  (C \circ D)\cr
\end{pmatrix} 
= 
\begin{pmatrix}
  \tx{NoChan}(A \circ B)\cr
  \otimes\cr
  \tx{NoChan}(C \circ D)
\end{pmatrix}
=
\begin{pmatrix}
    \tx{NoChan}(A) \circ
    \begin{pmatrix}
      \tx{NoChan}(B)\cr
      \otimes\cr
      1(\tx{Channels}(\tx{Chan}(A)))
    \end{pmatrix}
  \cr
  \otimes\cr
    \tx{NoChan}(C) \circ
    \begin{pmatrix}
      \tx{NoChan}(D)\cr
      \otimes\cr
      1(\tx{Channels}(\tx{Chan}(C)))
    \end{pmatrix}
\end{pmatrix}
$$
Next, apply the interchange lemma for packages, to get:
$$
\begin{pmatrix}
  \tx{NoChan}(A)\cr
  \otimes\cr
  \tx{NoChan}(C)
\end{pmatrix}
\circ
\begin{pmatrix}
  \tx{NoChan}(B)\cr
  \otimes\cr
  1(\tx{Channels}(\tx{Chan}(A)))\cr
  \otimes\cr
  \tx{NoChan}(D)\cr
  \otimes\cr
  1(\tx{Channels}(\tx{Chan}(C)))\cr
\end{pmatrix}
$$
Then, observe that:
$$
\tx{Channels}(S_1 \cup S_2) = \tx{Channels}(S_1) \otimes \tx{Channels}(S_2)
$$
We can use this, along with the commutativity of $\otimes$ to get:
$$
\begin{pmatrix}
  \tx{NoChan}(A)\cr
  \otimes\cr
  \tx{NoChan}(C)
\end{pmatrix}
\circ
\begin{pmatrix}
  \tx{NoChan}(B)\cr
  \otimes\cr
  \tx{NoChan}(D)\cr
  \otimes\cr
  1(\tx{Channels}(\tx{Chan}(A * C)))\cr
\end{pmatrix}
$$
Which is just:
$$
\tx{NoChan}
\left(
\begin{pmatrix} 
A\cr
*\cr
C\cr
\end{pmatrix} 
\circ
\begin{pmatrix} 
B\cr
*\cr
D\cr
\end{pmatrix} 
\right)
$$

$\blacksquare$
\end{lemma}

\begin{definition}[System Games]
Analogously to games, we define a \emph{system game} as a system $S$
with $\tx{In}(S) = \emptyset$.

$\square$
\end{definition}

\begin{definition}[System Equality]
  We say that two systems $A$, $B$ with the same shape are equal, written $A = B$,
  if:
  $$
  \tx{SysPack}(A) = \tx{SysPack}(B)
  $$

  $\square$
\end{definition}

\begin{definition}[System Indistinguishability]
  We say that two systems $A$, $B$ with the same shape are indistinguishable up to $\epsilon$,
  written $A \overset{\epsilon}{\approx} B$,
  if:
  $$
  \tx{SysPack}(A) \overset{\epsilon}{\approx} \tx{SysPack}(B)
  $$

  $\square$
\end{definition}

\begin{lemma}[Transitivity of System Equality]
  Given systems $A, B, C$, we have:
  \begin{enumerate}
    \item $A \equiv B, B \equiv C \implies A \equiv C$,
    \item $A = B, B = C \implies A = C$,
    \item $A \overset{\epsilon_1}{\approx} B, B \overset{\epsilon_2}{\approx} C \implies A \overset{\epsilon_1 + \epsilon_2}{\approx} C$.
  \end{enumerate}
  provided these expressions are well-defined.

  \txbf{Proof:} This follows immediately from the fact that equality and Indistinguishability
  for \emph{packages} satisfy similar relations, and the notions for systems are
  defined in terms of the package $\tx{SysPack}(\ldots)$.

  $\blacksquare$
\end{lemma}

\begin{lemma}[Composition Compatability]
  Given systems $A$, $B$, $B'$, we have:
  \begin{enumerate}
    \item $B = B' \implies A \circ B = A \circ B'$,
    \item $B \overset{\epsilon}{\approx} B' \implies A \circ B \overset{\epsilon}{\approx} A \circ B'$.
  \end{enumerate}
  provided these expressions are well-defined.

  \txbf{Proof:} We prove that
  $$
  \tx{SysPack}(A \circ B) = \tx{SysPack}(A) \circ \tx{SysPack}(B)
  $$
  which then clearly implies this lemma by application of the similar properties
  for packages.

  We start with:
  $$
  \tx{SysPack}(A \circ B) = \tx{NoChan}(A) \circ
  \begin{pmatrix}
    \tx{NoChan}(B)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(A)))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(A) \cup \tx{Chan}(B))\cr
    \otimes\cr
    1(\tx{In}(B))
  \end{pmatrix}
  $$
  We then use the fact that $\tx{Channels}(S \cup R) = \tx{Channels}(S) \otimes \tx{Channels}(R)$,
  and the interchange lemma, to get:
  $$
  \tx{NoChan}(A) \circ
  \begin{pmatrix}
    \tx{NoChan}(B)\cr
    \otimes\cr
    \tx{Channels}(\tx{Chan}(A))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(B))\cr
    \otimes\cr
    1(\tx{In}(B))
  \end{pmatrix}
  $$
  Apply interchange once more, to get:
  $$
  \tx{NoChan}(A) \circ
  \begin{pmatrix}
    1(\tx{In}(A))\cr
    \otimes\cr
    \tx{Channels}(\tx{Chan}(A))
  \end{pmatrix}
  \circ
    \tx{NoChan}(B)
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(B))\cr
    \otimes\cr
    1(\tx{In}(B))
  \end{pmatrix}
  $$
  Which is none other than:
  $$
  \tx{SysPack}(A) \circ \tx{SysPack}(B)
  $$
  concluding our proof.

  $\blacksquare$
\end{lemma}

\begin{lemma}[Strict Tensoring Compatability]
  Given systems $A$, $B$, $B'$, we have:
  \begin{enumerate}
    \item $B = B' \implies A \otimes B = A \otimes B'$,
    \item $B \overset{\epsilon}{\approx} B' \implies A \otimes B \overset{\epsilon}{\approx} A \otimes B'$.
  \end{enumerate}
  provided these expressions are well-defined.

\end{lemma}

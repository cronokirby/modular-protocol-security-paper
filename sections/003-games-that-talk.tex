\section{Games That Talk}

\subsection{Async Functions}

While the intuition of yield statements is simple, defining
them precisely is a bit more tricky.

\begin{definition}[Yield Statements]
We define the semantics of $\textbf{yield}$ by compiling functions with
such statements to functions without them.

Note that we don't define the semantics for functions which still contain references
to oracles.
Like before, we can delay the definition of semantics until all of the
pseudo-code has been inlined.

A first small change is to make it so that the function accepts one
argument, a binary string, and all yield points also accept binary
strings as continuation.
Like with plain packages, we can implement richer types on top by adding
additional checks to the well-formedness of binary strings, aborting
otherwise.

The next step is to make it so that all the local variables of the function $F$
are present in the global state.
So, if a local variable $v$ is present, then every use
of $v$ is replaced with a use of the global variable $F.v$ in the package.
This allows the state of the function to be saved across yields.

The next step is transforming all the control flow of a function to
use $\textbf{ifgoto}$, rather than structured programming constructs like
$\textbf{while}$ or $\textbf{if}$.
The function is broken into lines, each of which contains a single statement.
Each line is given a number, starting at $0$.
The execution of a function $F$ involves a special variable $\texttt{pc}$,
representing the current line being executing.
Excluding $\textbf{yield}$ and $\textbf{return}$ a single line statement has one of the
forms:
$$
\begin{aligned}
&\langle \texttt{var} \rangle \gets \langle \texttt{expr} \rangle\cr
&\langle \texttt{var} \rangle \xleftarrow{\$} \langle \texttt{dist} \rangle\cr
\end{aligned}
$$
which have well defined semantics already.
Additionally, after these statements, we set $\texttt{pc} \gets \texttt{pc} + 1$.

The semantics of $\textbf{ifgoto } \langle \texttt{expr} \rangle i$ is:
$$
\texttt{pc} \gets \textbf{ if } \langle \texttt{expr} \rangle \textbf{ then } i \textbf{ else } \texttt{pc} + 1
$$
This gives us a conditional jump, and by using $\texttt{true}$ as the condition,
we get a standard unconditional jump.

This allows us to define $\textbf{if}$ and $\textbf{while}$ statements
in the natural way.

Finally, we need to augment functions to handle $\textbf{yield}$ and $\textbf{return}$
statements.
To handle this, each function $F$ also has an associated variable
$F.\texttt{pc}$, which stores the program counter for the function.
This is different than the local $\texttt{pc}$ which is while the function is
execution.
$F.\texttt{pc}$ is simply used to remember the program counter after a yield
statement.

The function now starts with:
$$
\begin{aligned}
&\textbf{ifgoto } \texttt{true}\ F.\text{pc} 
\end{aligned}
$$
This has the effect of resuming execution at the saved program counter.

Furthermore, the input variable $x$ to $F$ is replaced with a special
variable $\texttt{input}$, which holds the input supplied to the function.
At the start of the function body, we add:
$$
0: F.x \gets \texttt{input}
$$
to capture the fact that the original input variable needs to get assigned
to the input to the function.

The semantics of $F.m \gets \textbf{yield } v$ are:
$$
\begin{aligned}
(i-1):&\ F.\text{pc} \gets i + 1\cr
i:&\ \textbf{return } (\texttt{yield}, v)\cr
(i + 1):&\ F.m \gets \texttt{input}
\end{aligned}
$$

The semantics of $\textbf{return } v$ become:
$$
\begin{aligned}
&F.\text{pc} \gets 0\cr
&\textbf{return } (\texttt{return}, v)
\end{aligned}
$$
The main difference is that we annotate the return value to be different than
yield statements, but otherwise the semantics are the same.

$\square$
\end{definition}

Note that while calling a function which can yield will notify the
caller as to whether or not the return value was \emph{yielded}
or \emph{returned}, syntactically the caller often ignores this,
simply doing $x \gets F(\ldots)$, meaning that they simply use
return value $x$, discarding the tag.

\begin{syntax}
In many cases, no value is yielded, or returned back, which we can write as:
$$
\textbf{yield}
$$
which is shorthand for:
$$
\bullet \gets \textbf{yield } \bullet
$$
i.e. just yielding a dummy value and ignoring the result.

$\square$
\end{syntax}

In such situations, often we don't particularly care about the intermediate
yields of a function, and want to wait for the final result,
potentially yielding to our own caller.
We define these semantics via the $\textbf{await}$ statement.

\begin{syntax}[Await Statements]
We define the semantics of $v \gets \await F(\ldots)$ in a straightforward way:
$$
\begin{aligned}
&(\tx{tag}, v) \gets (\texttt{yield}, \bot)\cr
&\txbf{while } \tx{tag} = \texttt{yield}:\cr
\pind{1}\txbf{if } v \neq \bot:\cr
\pind{2}\txbf{yield}\cr
\pind{1}(\tx{tag}, v) \gets F(\ldots)\cr
\end{aligned}
$$
In other words, we keep calling the function until it actually returns
its final value, but we do yield to our caller whenever our function yield, but we do yield to our caller whenever our function yields.

$\square$
\end{syntax}

Sometimes we want to await several values at once, returning the first
one which completes. To that end, we define the $\textbf{select}$ statement.

\begin{syntax}[Select Statements]
Select statements generalize await statements in that they allow waiting
for multiple events concurrently.

More formally, we define:
$$
\begin{aligned}
&\txbf{select}:\cr
\pind{1}v_1 \gets \await F_1(\ldots):\cr
\pind{2} \langle \tx{body}_1 \rangle\cr
\pind{1}\vdots\cr
\pind{1}v_n \gets \await F_n(\ldots):\cr
\pind{2} \langle \tx{body}_n \rangle\cr
\end{aligned}
$$
As follows:
$$
\begin{aligned}
&(\tx{tag}_i, v_i) \gets (\texttt{yield}, \bot)\cr
&i \gets 0\cr
&\txbf{while } \nexists i.\ \tx{tag}_i \neq \texttt{yield}:\cr
\pind{1} \txbf{if } i \geq n:\cr
\pind{2} i \gets 0\cr
\pind{2} \txbf{yield}\cr
\pind{1} i \gets i + 1\cr
\pind{1} (\tx{tag}_i, v_i) \gets F_i(\ldots)\cr
&\langle \tx{body}_i \rangle
\end{aligned}
$$
Note that the order in which we call the functions is completely deterministic,
and fair.
It's also important that we yield, like with await statements, but we only
do so after having pinged each of our underlying functions at least once.
This is so that if one of the function is immediately ready, we never yield.

$\square$
\end{syntax}

\subsection{Channels and System Composition}


\begin{definition}[Systems]
A \emph{system} is a package which uses channels.

We denote by $\text{InChan(S)}$ the set of channels the system receives on,
and $\text{OutChan(S)}$ the set of channels the system sends on,
and define
$$
\text{Chan}(S) := \text{OutChan}(S) \cup \text{InChan}(S)
$$
$\square$
\end{definition}

\begin{definition}
We can compile systems to not use channels.
We denote by $\text{NoChan}(S)$ the package corresponding to
a system $S$, with the use of channels replaced with function calls.

Channels define two new syntactic constructions, for sending and receiving
along a channel.
We replace these with function calls as follows:


Sending, with $m \Rightarrow P$ becomes:
$$
\text{Channels}.\tx{Send}_P(m)
$$

Receiving, with $m \Leftarrow P$ becomes:
$$
m \gets \await \text{Channels}.\tx{Recv}_P()
$$
Receiving is an asynchronous function, because the channel might not have
any available messages for us.

These function calls are parameterized by the channel, meaning
that that we have a separate function for each channel.

$\square$
\end{definition}

\begin{game}{game:Channels}{Channels}
\package{Channels($\{A_1, \ldots, A_n\}$)}{
&q[A_i] \gets \text{FifoQueue.New()}\cr
\cr
&\underline{\tx{Send}_{A_i}(m)\tx{:}}\cr
\pind{1} q[A_i].\tx{Push}(m)\cr
\cr
&\underline{\tx{Recv}_{A_i}()\tx{:}}\cr
\pind{1} \txbf{while } q[A_i].\tx{IsEmpty()}\cr
\pind{2} \txbf{yield}\cr
\pind{1} q[A_i].\tx{Next}()\cr
}
\end{game}

One consequence of this definition with separate functions for each channel
is that $\text{Channels}(S) \otimes \text{Channels}(R) = \text{Channels}(S \cup R)$.

Armed with the syntax sugar for channels, and the $\tx{Channels}$ game,
we can convert a system $S$ into a package via:
$$
\text{SysPack}(S) := \text{NoChan}(S) \circ (\text{Channels}(\tx{Chan}(S)) \otimes 1(\tx{In}(S)))
$$
This package will have the same input and output functions as the system $S$,
but with the usage of channels replaced with actual semantics.

This allows us to lift our standard equality relations on packages onto
\emph{systems}.
\begin{definition}
Given some equality relation $\sim$ on packages, we can lift that relation
to systems by definining:
$$
A \sim B \iff \text{SysPack}(A) \sim \text{SysPack}(B)
$$
$\square$
\end{definition}

\begin{definition}[System Tensoring]
Given two systems, $A$ and $B$, with \(\text{Out}(A) \cap \text{Out}(B) = \emptyset\), we can define their tensor product $A * B$,
which is any system satisfying:
$$
\tx{SysPack}(A * B) =
\begin{pmatrix}
&\tx{NoChan}(A)\cr
&\otimes\cr
&\tx{NoChan}(B)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
&\text{Channels}(\tx{Chan}(A) \cup \tx{Chan}(B))\cr
&\otimes\cr
&1(\tx{In}(A) \cup \tx{In}(B))\cr
\end{pmatrix}
$$

$\square$
\end{definition}

Note that combining the definition above with the definition of $\text{SysPack}$
means that:
$$
\begin{aligned}
&\text{NoChan}(A * B) = \text{NoChan}(A) \otimes \text{NoChan}(B)\cr
&\text{Chan}(A * B) = \text{Chan}(A) \cup \text{Chan}(B)\cr
&\text{In}(A * B) = \text{In}(A) \cup \text{In}(B)\cr
\end{aligned}
$$

This implies the following lemma.

\begin{lemma}
System tensoring is associative, i.e. $A * (B * C) = (A * B) * C$.
\txbf{Proof:} Starting from the definition of tensoring, we have:
$$
\tx{SysPack}(A * (B * C)) =
\begin{pmatrix}
&\tx{NoChan}(A)\cr
&\otimes\cr
&\tx{NoChan}(B * C)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
&\text{Channels}(\tx{Chan}(A) \cup \tx{Chan}(B * C))\cr
&\otimes\cr
&1(\tx{In}(A) \cup \tx{In}(B * C))\cr
\end{pmatrix}
$$
We can then apply the corrollaries we've just derived to show that this
is equal to:
$$
\begin{pmatrix}
&\tx{NoChan}(A)\cr
&\otimes\cr
&\tx{NoChan}(B)\cr
&\otimes\cr
&\tx{NoChan}(C)\cr
\end{pmatrix}
\circ
\begin{pmatrix}
  &\text{Channels}(\tx{Chan}(A) \cup \tx{Chan}(B) \cup \tx{Chan}(C))\cr
&\otimes\cr
  &1(\tx{In}(A) \cup \tx{In}(B) \cup \tx{In}(C))\cr
\end{pmatrix}
$$
(Using the associativity of $\otimes$ for \emph{packages} as well).

With the same reasoning, we can derive the same package from $(A * B) * C$,
letting us conclude that $\text{SysPack}(A * (B * C)) = \text{SysPack}((A * B) * C)$,
and thus that $A * (B * C) = (A * B) * C$.

$\blacksquare$
\end{lemma}

\begin{lemma}
System tensoring is commutative, i.e. $A * B = B * A$
\txbf{Proof:} This follows from the commutativity of $\otimes$ and $\cup$.
$\blacksquare$
\end{lemma}

\begin{definition}[Overlapping Systems]
Two systems $A$ and $B$ overlap if $\text{Chan}(A) \cap \text{Chan}(B) \neq \emptyset$.

In the case of non-overlapping systems, we write $A \otimes B$ instead of $A * B$,
insisting on the fact that they don't communicate.
\end{definition}

\begin{definition}[System Composition]
Given two systems, $A$ and $B$, we can define their (horizontal) composition
$A \circ B$ as any system, provided a few constraints hold:
\begin{itemize}
\item $A$ and $B$ do not overlap ($\text{Chan}(A) \cap \tx{Chan}(B) = \emptyset$)
\item $\tx{In}(A) \subseteq \tx{Out}(B)$
\end{itemize}

With these in place, we define the composition as any system such that:
$$
\text{SysPack}(A \circ B) =
\text{SysPack}(A) \circ \text{SysPack}(B)
$$

$\square$
\end{definition}

\begin{lemma}
System composition is associative, i.e. $A \circ (B \circ C) = (A \circ B) \circ C$.
\txbf{Proof:} This follows from the associativity of $\circ$ for \emph{packages}. $\blacksquare$
\end{lemma}

\begin{lemma}[Interchange Lemma]
Given systems $A, B, C, D$ such that $A \circ B$ and $C \circ D$ are well defined,
$A * C$ and $B * D$ are well defined,
and neither $A$ nor $C$ overlap with $B$ or $D$, i.e.
the following relation holds:
$$
\begin{pmatrix} 
A\cr
*\cr
C\cr
\end{pmatrix} 
\circ
\begin{pmatrix} 
B\cr
*\cr
D\cr
\end{pmatrix} 
=
\begin{matrix} 
  (A \circ B)\cr
*\cr
  (C \circ D)\cr
\end{matrix} 
$$

\txbf{Proof:}
First, we need to develop a few general facts about $\tx{SysPack}(A \circ B)$, $\tx{Chan}(A \circ B)$
and $\tx{NoChan}(A \circ B)$, like those we developed for $A * B$.

As a consequence of how $A \circ B$ is defined, by unrolling $\text{SysPack}(A \circ B)$,
we get:
$$
  \tx{SysPack}(A \circ B) =
  \tx{NC}(A) \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(A))\cr
    \otimes\cr
    1(\tx{In}(A))
  \end{pmatrix}
  \circ \tx{NC}(B) \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(B))\cr
    \otimes\cr
    1(\tx{In}(B))
  \end{pmatrix}
$$
Applying the interchange lemma for packages a couple times, we then get:
$$
  \tx{NC}(A) \circ
  \begin{pmatrix}
    \tx{NC}(B)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(A)))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(A)) \otimes \tx{Channels}(\tx{Chan}(B))\cr
    \otimes\cr
    1(\tx{In}(B))
  \end{pmatrix}
$$

And then, recalling
that $\tx{Channels}(S) \otimes \tx{Channels}(R) = \tx{Channels}(S \cup R)$,
we conclude that:
$$
\begin{aligned}
  &\tx{NoChan}(A \circ B) =
  \tx{NC}(A) \circ
  \begin{pmatrix}
    \tx{NC}(B)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(A)))
  \end{pmatrix}
  \cr
  &\tx{Chan}(A \circ B) = \tx{Chan}(A) \cup \tx{Chan}(B)\cr
\end{aligned}
$$

Next we apply these facts, along with those derived for $A * B$ to tackle the main lemma.

Starting from $\tx{SysPack}((A * C) \circ (B * D))$, we can apply the above
results to get:
$$
  \tx{NC}(A * C) \circ
  \begin{pmatrix}
    \tx{NC}(B * D)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(A * C)))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(A * C) \cup \tx{Chan}(B * D))\cr
    \otimes\cr
    1(\tx{In}(B * D))
  \end{pmatrix}
$$
Then, applying what we know about $A * B$ in general, we get:
$$
  \begin{pmatrix}
    \tx{NoChan}(A)\cr
    \otimes\cr
    \tx{NoChan}(C)
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{NoChan}(B)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(A)))\cr
    \otimes\cr
    \tx{NoChan}(D)\cr
    \otimes\cr
    1(\tx{Channels}(\tx{Chan}(C))
  \end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(A, B, C, D))\cr
    \otimes\cr
    1(\tx{In}(B, D))
  \end{pmatrix}
$$
Applying the interchange lemma for packages again, along with 
what we know about $A \circ B$, we get:
$$
\begin{pmatrix}
  \tx{NoChan}(A \circ B)\cr
  \otimes\cr
  \tx{NoChan}(C \circ D)
\end{pmatrix}
  \circ
  \begin{pmatrix}
    \tx{Channels}(\tx{Chan}(A, B, C, D))\cr
    \otimes\cr
    1(\tx{In}(B, D))
  \end{pmatrix}
$$
Noting that $\tx{Chan}(A, B, C, D) = \tx{Chan}(A \circ B, C \circ D)$,
and that $\tx{In}(B, D) = \tx{In}(A \circ B, C \circ D)$, we realize that the
expression above is equal to:
$$
\tx{SysPack}((A \circ B) * (C \circ D))
$$

$\blacksquare$
\end{lemma}

\begin{definition}[System Games]
Analogously to games, we define a \emph{system game} as a system $S$
with $\tx{In}(S) = \emptyset$.
\end{definition}

\begin{definition}[System Game Reductions]
We can also define notions of reductions for system game (pairs).

First, we define:
$$
\epsilon(\mathcal{A} \circ S_b) := \epsilon(\mathcal{A} \circ \tx{SysPack}(S_b))
$$

We then also use the syntax sugar of:
$$
S_b \leq f(G_b^1, G_b^2, \ldots)
$$
as shorthand for, $\forall \mathcal{A}.\ \exists \mathcal{B}_1, \ldots$:
$$
\epsilon(\mathcal{A} \circ S_b) \leq f(\epsilon(\mathcal{B}_1 \circ G_b^1), \epsilon(\mathcal{B}_2 \circ G_b^2), \ldots)
$$

We also sometimes omit explicitly writing $S_b$, instead writing just $S$,
if it's clear that we're talking about a pair of systems.

$\square$
\end{definition}

Similar properties hold for reductions:

\begin{lemma}
$A \circ G_b \leq G_b$.

\textbf{Proof:} $\tx{SysPack}(A \circ G_b) = \tx{SysPack}(A) \circ \tx{SysPack}(G_b) \leq \tx{SysPack}(G_b)$. $\blacksquare$
\end{lemma}

\begin{lemma}
There exists system games $A$, $G_B$ such that $G_B$ is secure
but $A * G_b$ is insecure.

\textbf{Proof:}
Consider:
\package{$G_b$}{
&\pfn{Cheat}{}\cr
\pind{1}\psend{b}{P}\cr
\pind{1}\precv{\hat{b}}{Q}\cr
\pind{1}\preturn{\hat{b}}\cr
}
\package{$A$}{
&\pfn{Run}{}\cr
\pind{1}\precv{b}{P}\cr
\pind{1}\psend{b}{Q}\cr
}
Clearly, $G_b$ is secure in isolation, since no other system is present
to provide a value on $Q$, so $G_b$ will block forever in the cheating function.

However, when linked with $A$, this cheating function will return $b$,
allowing an adversary to break the game with probability $1$.

$\blacksquare$
\end{lemma}
